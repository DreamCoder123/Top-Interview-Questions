1) What is Loose Coupling?

Loose coupling : In simple words, loose coupling means they are mostly independent. If the only knowledge that class A has about class B, is what class B has exposed through its interface, then class A and class B are said to be loosely coupled. In order to over come from the problems of tight coupling between objects, spring framework uses dependency injection mechanism with the help of POJO/POJI model and through dependency injection its possible to achieve loose coupling.
Example : If you change your shirt, then you are not forced to change your body – when you can do that, then you have loose coupling. When you can’t do that, then you have tight coupling. The examples of Loose coupling are Interface, JMS.
// Java program to illustrate 
// loose coupling concept
public interface Topic
{
    void understand();
}
class Topic1 implements Topic {
	public void understand()
    	{
        	System.out.println("Got it");
    	}
} class Topic2 implements Topic {
	public void understand()
    	{
        	System.out.println("understand");
    	}
}public class Subject {
	public static void main(String[] args)
    	{
        	Topic t = new Topic1();
        	t.understand();
    	}
}

2) What is Dependency?

A typical Java application will have three layers in its architecture: web, business and data.

The web layer
The business layer
The data layer
In the above scenario:

Web Layer depends on Business Layer. The business layer is a dependency for the web layer.
Business layer depends on Data Layer. The data layer is a dependency for the business layer.

3) What is IOC (Inversion of Control)?
In general, when a class depends on another class then the dependent class creates the object of its
dependency class directly, and then uses(call) its methods, it is called the dependency object created in the main control.
But if some external entity is taking care of creating the dependency object then we say that control is inverted to some external entity, this is called Inversion of Control (IOC).

4) What is Dependency Injection?
Dependency Injection is a fundamental aspect of the Spring framework, through which the Spring container “injects” objects into other objects or “dependencies”.

Simply put, this allows for loose coupling of components and moves the responsibility of managing components onto the container.

5) Can you give few examples of Dependency Injection ?
Example Car Class might need a reference to an Engine class . These required classe are called dependencies and in the example the car class is dependent on having an instance of the  engine class to run.

6) What is Auto Wiring?
Autowiring feature of spring framework enables you to inject the object dependency implicitly. It internally uses setter or constructor injection.
Autowiring can't be used to inject primitive and string values. It works with reference only.
1)	no:-		It is the default autowiring mode. It means no autowiring bydefault.
2)	byName:-	The byName mode injects the object dependency according to name of the bean. In such case, property name and bean name must be same. It 			internally calls setter method.
3)	byType:-	The byType mode injects the object dependency according to type. So property name and bean name can be different. It internally calls setter 			     method.
4)	constructor:-	The constructor mode injects the dependency by calling the constructor of the class. It calls the constructor having large number of 				parameters.
5)	autodetect:-	It is deprecated since Spring 3.

7) What are the important roles of an IOC Container?
	The IoC container is responsible to instantiate, configure and assemble the objects. The IoC container gets informations from the XML file and works 		accordingly. The main tasks performed by IoC container are:
	1) to instantiate the application class
	2) to configure the object
	3) to assemble the dependencies between the objects
	
	There are two types of IoC containers. They are:

	BeanFactory
	ApplicationContext

8) 	What are Bean Factory and Application Context?
	Spring Framework provides two of the most fundamental and important packages, they are the org.springframework.beans and org.springframework.context packages. 		Code in these packages provides the basis for Spring’s Inversion of Control/Dependency Injection features. Spring containers are responsible for creating bean 		objects and injecting them into the classes. The two containers are namely,

	BeanFactory(I) – Available in org.springframework.beans.factory package.
	ApplicationContext(I) – Available in rg.springframework.context package.
	
	The BeanFactory Interface
	This is the root interface for accessing a Spring bean container. It is the actual container that instantiates, configures, and manages a number of beans. 	   These beans collaborate with one another and thus have dependencies between themselves. These dependencies are reflected in the configuration data used by the 	  BeanFactory. This interface is implemented by the objects that hold a number of bean definitions, each uniquely identified by a String name. The most common 	         implementation class used for this BeanFactory is XmlBeanFactory available in org.springframework.beans.factory.xml package. 


	Note: BeanFactory is deprecated from Spring 3.0.

	Example code:
	ClassPathResource resource = new ClassPathResource("beans.xml");
	XmlBeanFactory factory = new XmlBeanFactory(resource);
 
 

	The ApplicationContext Interface
 

	This interface is designed on top of the BeanFactory interface. The ApplicationContext interface is the advanced container that enhances BeanFactory 		functionality in a more framework-oriented style. While the BeanFactory provides basic functionality for managing and manipulating beans, often in a 		programmatic way, the ApplicationContext provides extra functionality like MessageSource, Access to resources, Event propagation to beans, Loading of multiple 		(hierarchical) contexts etc. There are so many implementation classes that can be used such as ClassPathXmlApplicationContext,FileSystemXmlApplicationContext, 		AnnotationConfigWebApplicationContext etc.


	Example code:
	ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
	
	
9) 	Can you compare Bean Factory with Application Context?

	BeanFactory loads beans on-demand, while ApplicationContext loads all beans at startup. Thus, BeanFactory is lightweight as compared to ApplicationContext. 	    Let's understand it with an example.
	
	public class Student {
    public static boolean isBeanInstantiated = false;

    public void postConstruct() {
        setBeanInstantiated(true);
    }
}

10) How do you create an application context with Spring?

Step 1: Creating a Spring Project using Spring Initializer as pictorially depicted below.



Step 2: Create Student class under com.gfg.demo.domain and AppConfig class under com.gfg.demo.config packages. The AppConfig is the configuration class that contains all the Java beans configured using Java Based Configuration. The Student class is the POJO class.

Class 1: AppConfig class
@Configuration

// Class
public class AppConfig {

  @Bean

  // Method
  public Student student() {

    return new Student(1, "Geek");
  }
}
Class 2: Student class
// Class
public class Student {

  // member variables
  private int id;
  private String name;

  // Constructor 1
  public Student() {}

  // Constructor 2
  public Student(int id, String name) {
    this.id = id;
    this.name = name;
  }

  // Method of this class
  // @Override
  public String toString() {

    return "Student{" + "id=" + id + ", name='" + name + '\'' + '}';
  }
}
Step 3: Now the Main Application class at the root contains the creation of a container.

// Class
// @SpringBootApplication
public class DemoApplication {

  // Main driver method
  public static void main(String[] args) {

    // SpringApplication.run(DemoApplication.class, args);

    // Creating its object
    ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
    Student student = context.getBean(Student.class);

    // Print and display
    System.out.println(student);
  }
}
Step 4: The SpringApplication.run() method is provided by default in the main class when the SpringBoot project is created. It creates the container, creates beans, manages dependency injection and life cycle of those beans. This is done using @SpringBootApplication annotation.


Q11 How does Spring know where to search for Components or Beans?


If you understand Component Scan, you understand Spring.

Spring is a dependency injection framework. It is all about beans and wiring in dependencies.

The first step of defining Spring Beans is by adding the right annotation — @Component or @Service or @Repository.

However, Spring does not know about the bean unless it knows where to search for it.

This part of “telling Spring where to search” is called a Component Scan.

You define the packages that have to be scanned.

Once you define a Component Scan for a package, Spring would search the package and all its sub packages for components/beans.

Defining a Component Scan

If you are using Spring Boot, check the configuration in Approach 1.
If you are doing a JSP/Servlet or a Spring MVC application without using Spring Boot, use Approach 2.
Approach 1: Component Scan in a Spring Boot Project

If your other package hierarchies are below your main app with the @SpringBootApplication annotation, you’re covered by the implicit Component Scan. If there are beans/components in other packages that are not sub-packages of the main package, you should manually add them as @ComponentScan

Consider below class

package com.in28minutes.springboot.basics.springbootin10steps;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ConfigurableApplicationContext;
@SpringBootApplication
public class SpringbootIn10StepsApplication {
    public static void main(String[] args) {
        ApplicationContext applicationContext =
            SpringApplication.run(SpringbootIn10StepsApplication.class, args);
        for (String name: applicationContext.getBeanDefinitionNames()) {
            System.out.println(name);
        }
    }
}
@SpringBootApplication is defined in the SpringbootIn10StepsApplication class which is in the package com.in28minutes.springboot.basics.springbootin10steps

@SpringBootApplication defines an automatic Component Scan on the package com.in28minutes.springboot.basics.springbootin10steps.

You are fine if all your components are defined in the above package or a sub-package of it.

However, let’s say one of the components is defined in package com.in28minutes.springboot.somethingelse

In this case, you would need to add the new package into Component Scan.

You have two options:

Option 1:

@ComponentScan(“com.in28minutes.springboot”)
@SpringBootApplication
public class SpringbootIn10StepsApplication {...}
Option 2:: Define as array

@ComponentScan({"com.in28minutes.springboot.basics.springbootin10steps","com.in28minutes.springboot.somethingelse"})
@SpringBootApplication
public class SpringbootIn10StepsApplication {...}
Approach 2: Non-Spring Boot Project

Option 1:

@ComponentScan(“com.in28minutes)
@Configuration
public class SpringConfiguration {...}
Option 2:

@ComponentScan({"com.in28minutes.package1","com.in28minutes.package2"})
@Configuration
public class SpringConfiguration {...}
XML application context:

<context:component-scan base-package="com.in28minutes" />
Specific multiple packages:

<context:component-scan base-package="com.in28minutes.package1, com.in28minutes.package2" />


Q12 What is a component scan?
When developing Spring Boot applications, you need to tell the Spring Framework where to look for Spring components. Using component scan is one method of asking Spring to detect Spring managed components. Spring needs the information to locate and register all the Spring components with the application context when the application starts.

Spring can auto scan, detect, and instantiate components from pre-defined project packages. It can auto scan all classes annotated with the stereotype annotations @Component, @Controller, @Service, and @Repository


Q13 How do you define a component scan in XML and
Java Configurations?

To autodetect these classes and register the corresponding beans, you need to include the following element in XML, where the base-package element is a common parent package for the two classes. (Alternatively, you can specify a comma-separated list that includes the parent package of each class.)

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context-3.0.xsd">
               
     <context:component-scan base-package="org.example"/>
     
</beans>


With Spring, we use the @ComponentScan annotation along with the @Configuration annotation to specify the packages that we want to be scanned. @ComponentScan without arguments tells Spring to scan the current package and all of its sub-packages.

Let's say we have the following @Configuration in com.baeldung.componentscan.springapp package:


freestar
@Configuration
@ComponentScan
public class SpringComponentScanApp {
    private static ApplicationContext applicationContext;

    @Bean
    public ExampleBean exampleBean() {
        return new ExampleBean();
    }

    public static void main(String[] args) {
        applicationContext = 
          new AnnotationConfigApplicationContext(SpringComponentScanApp.class);

        for (String beanName : applicationContext.getBeanDefinitionNames()) {
            System.out.println(beanName);
        }
    }
}


Q14 How is it done with Spring Boot?

Already answered above.

Q15 What does @Component signify?

Spring Component
In layman terms, a Component is responsible for some operations. Spring framework provides three other specific annotations to be used when marking a class as Component.

Service: Denotes that the class provides some services. Our utility classes can be marked as Service classes.
Repository: This annotation indicates that the class deals with CRUD operations, usually it’s used with DAO implementations that deal with database tables.
Controller: Mostly used with web applications or REST web services to specify that the class is a front controller and responsible to handle user request and return appropriate response.
Note that all these four annotations are in package org.springframework.stereotype and part of spring-context jar. Most of the time our component classes will fall under one of its three specialized annotations, so you may not use @Component annotation a lot.

Spring Component Example
Let’s create a very simple Spring maven application to showcase the use of Spring Component annotation and how Spring autodetects it with annotation-based configuration and classpath scanning. Create a maven project and add following spring core dependency.

<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-context</artifactId>
	<version>5.0.6.RELEASE</version>
</dependency>
That’s all we need to get the spring framework core features. Let’s create a simple component class and mark it with @Component annotation.

package com.journaldev.spring;

import org.springframework.stereotype.Component;

@Component
public class MathComponent {

	public int add(int x, int y) {
		return x + y;
	}
}
Now we can create an annotation based spring context and get the MathComponent bean from it.

package com.journaldev.spring;

import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class SpringMainClass {

	public static void main(String[] args) {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		context.scan("com.journaldev.spring");
		context.refresh();

		MathComponent ms = context.getBean(MathComponent.class);

		int result = ms.add(1, 2);
		System.out.println("Addition of 1 and 2 = " + result);

		context.close();
	}

}


Q16 What does @Autowired signify?

The @Autowired annotation provides more fine-grained control over where and how autowiring should be accomplished. The @Autowired annotation can be used to autowire bean on the setter method just like @Required annotation, constructor, a property or methods with arbitrary names and/or multiple arguments.


Q17 What’s the difference Between @Controller,@Component, @Repository, and @Service	
Annotations in Spring?

The major difference between these stereotypes is that they are used for different classifications. When we annotate a class for auto-detection, we should use the respective stereotype.

Now let's go through them in more detail.

1)  @Controller
The @Controller annotation indicates that a particular class serves the role of a controller. Spring Controller annotation is typically used in combination with annotated handler methods based on the @RequestMapping annotation. It can be applied to classes only. It’s used to mark a class as a web request handler. 

2) @Component
We can use @Component across the application to mark the beans as Spring's managed components. Spring will only pick up and register beans with @Component, and doesn't look for @Service and @Repository in general.

They are registered in ApplicationContext because they are annotated with @Component:

@Component
public @interface Service {
}
Copy
@Component
public @interface Repository {
}
Copy
@Service and @Repository are special cases of @Component. They are technically the same, but we use them for the different purposes.

3) @Repository
@Repository’s job is to catch persistence-specific exceptions and re-throw them as one of Spring’s unified unchecked exceptions.

For this, Spring provides PersistenceExceptionTranslationPostProcessor, which we are required to add in our application context (already included if we're using Spring Boot):

<bean class=
  "org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor"/>
Copy
This bean post processor adds an advisor to any bean that’s annotated with @Repository.

4) @Service
We mark beans with @Service to indicate that they're holding the business logic. Besides being used in the service layer, there isn't any other special use for this annotation.

4 Conclusion
In this article, we learned about the differences between the @Component, @Repository, and @Service annotations. We examined each annotation separately to understand their areas of use.

In conclusion, it's always a good idea to choose the annotation based on their layer conventions.


Q18  what is the default scope of a bean?

The default scope for the bean is a singleton, like the example below, in which we haven't explicitly given a scope. Singleton means that the Spring container creates only one instance of the bean, and cached in memory, and all the requests for that bean will return a shared reference to the same bean.


Q19	Are Spring beans thread safe?
	Is Spring singleton thread safe? The short answer is: no, it isn't. And you probably already know why. It's because of the long life cycle of singleton beans.


Q20  What are the other scopes available?

singleton.
prototype.
request.
session.
application.
websocket.

Singleton
When we define a bean with the singleton scope, the container creates a single instance of that bean; all requests for that bean name will return the same object, which is cached. Any modifications to the object will be reflected in all references to the bean. This scope is the default value if no other scope is specified.

Prototype
A bean with the prototype scope will return a different instance every time it is requested from the container. It is defined by setting the value prototype to the @Scope annotation in the bean definition:

Request & Session 
The request scope creates a bean instance for a single HTTP request, while the session scope creates a bean instance for an HTTP Session.
The application scope creates the bean instance for the lifecycle of a ServletContext, and the websocket scope creates it for a particular WebSocket session.

Application scope
The application scope creates the bean instance for the lifecycle of a ServletContext.

This is similar to the singleton scope, but there is a very important difference with regards to the scope of the bean.
When beans are application scoped, the same instance of the bean is shared across multiple servlet-based applications running in the same ServletContext, while singleton scoped beans are scoped to a single application context only.

Webscoket Scope

When first accessed, WebSocket scoped beans are stored in the WebSocket session attributes. The same instance of the bean is then returned whenever that bean is accessed during the entire WebSocket session.
We can also say that it exhibits singleton behavior, but limited to a WebSocket session only.


Q21 How is Spring’s singleton bean different from Gang of Four Singleton Pattern?

Spring Singleton is very different from Singleton pattern. Spring guarantees to create only one bean instance for given bean id definition per container.Singleton pattern ensures that one and only one instance is created per ClassLoader. 

Q22 What are the different types of dependency
Spring provides an IoC container which is responsible for instantiating, configuring and managing the lifecycle of Spring beans. In Spring, any POJO is referred to as a Spring bean.

The Spring ApplicationContext interface represents its IoC container and we have several implementation classes available. Some of these include ClassPathXmlApplicationContext, FileSystemXmlApplicationContext, and WebApplicationContext.

Let’s instantiate the Spring container using ClassPathXmlApplicationContext:
ApplicationContext appContext 
  = new ClassPathXmlApplicationContext("applicationContext.xml");

Here, the applicationContext.xml is the file that holds the metadata required to assemble beans at runtime.
Spring supports three types of dependency injection:

1. Constructor-Based Injection:
In a constructor-based injection, Spring will use the matching constructor to resolve and inject the dependency.

We can either configure the beans in applicationContext.xml:
<bean id="address" class="com.programmergirl.domain.Address"/>
<bean id="person" class="com.programmergirl.domain.Person">
    <constructor-arg ref="address"/>
</bean>

Or, we can enable the <component-scan/> in our applicationContext.xml:
<context:component-scan base-package="com.programmergirl.domain" />

On enabling component scan, we can make the Spring configurations using the annotations. Our classes would then look like:
package com.programmergirl.domain;
@Component
public class Person {
    private Address address;
    @Autowired
    public Person(Address address) {
        this.address = address;
    }
}
package com.programmergirl.domain;
@Component
public class Address {
   ...
}

Spring, by default, wires the beans by their type. If there are more than one beans of the same type, we can use @Qualifier annotation to reference a bean by its name:
@Component
public class Person {
    private Address address;
    @Autowired
    @Qualifier("address1")
    public void setAddress(Address address) {
        this.address = address;
    }
}

Assuming we have two Address beans – address1 and address2, our address1 bean will be injected into Person class while dependency resolution.
2. Setter Injection:
Setter-based dependency injection is achieved through the setter method on the bean after instantiating it using a no-arg constructor or no-argument static factory.

We can configure it using XML as:
<bean id="address" class="com.programmergirl.domain.Address"/>
<bean id="person" class="com.programmergirl.domain.Person">
    <property name="address" ref="address"/>
</bean>

On the other hand, when using annotations, we’ll have:
@Component
public class Person {
    
    private Address address;
    ...
    @Autowired
    public void setAddress(Address address) {
        this.address = address;
    }
    
}
3. Property-Based Injection:
We can also inject dependencies using fields or properties of a class. To do so, we can simply use the @Autowired annotation over the field:
@Component
public class Person {
    @Autowired
    private Address address;
    ...
}


Q23 What is setter injection?

Setter Dependency Injection (SDI): This is the simpler of the two DI methods. In this, the DI will be injected with the help of setter and/or getter methods. Now to set the DI as SDI in the bean, it is done through the bean-configuration file For this, the property to be set with the SDI is declared under the <property> tag in the bean-config file.

Q24 What is constructor injection?

Constructor Dependency Injection (CDI): In this, the DI will be injected with the help of constructors. Now to set the DI as CDI in bean, it is done through the bean-configuration file For this, the property to be set with the CDI is declared under the <constructor-arg> tag in the bean-config file.

Q25  How do you choose between setter and constructor injections?

When to use Setter Injection and when to use Constructor Injection?
If there is only one property in a spring bean class then use constructor injection as constructor executes before methods constructor injection will be faster than setter injection. 

If spring bean class is having more than one property then it is better to use setter injection because it reduces burden on the programmer. Setter injection reduces burden on the programmer because programmer need not to worry about index, type of parameters as in the case of constructor injection. 

It is not mandatory that all properties must be configured for injection. Properties can be left with their default values. 


Q26 What are the different options available to create Application Contexts for Spring?	
	
ApplicationContext Implementation Classes

There are different types of Application containers provided by Spring for different requirements as listed below which later onwards are described alongside with declaration, at lastly providing an example to get through the implementation part with the pictorial aids. Containers are as follows:


AnnotationConfigApplicationContext container 
AnnotationConfigWebApplicationContext
XmlWebApplicationContext
Container 1: AnnotationConfigApplicationContext

AnnotationConfigApplicationContext class was introduced in Spring 3.0. It accepts classes annotated with @Configuration, @Component, and JSR-330 compliant classes. The constructor of AnnotationConfigApplicationContext accepts one or more classes. For example, in the below declaration, two Configuration classes Appconfig and AppConfig1 are passed as arguments to the constructor. The beans defined in later classes will override the same type and name beans in earlier classes when passed as arguments. For example, AppConfig and AppConfig1 have the same bean declaration. The bean defined in AppConfig1 overrides the bean in AppConfig.

Syntax: Declaration

ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class, AppConfig1.class);
Note: Add the following to the properties file in the IDE to allow the spring to override beans.

spring.main.allow-bean-definition-overriding=true
Container 2: AnnotationConfigWebApplicationContext

AnnotationConfigWebApplicationContext class was introduced in Spring 3.0. It is similar to AnnotationConfigApplicationContext for a web environment. It accepts classes annotated with @Configuration, @Component, and JSR-330 compliant classes. These classes can be registered via register() method or passing base packages to scan() method. This class may be used when we configure ContextLoaderListener servlet listener or a DispatcherServlet in a web.xml. From Spring 3.1, this class can be instantiated and injected to DispatcherServlet using java code by implementing WebApplicationInitializer, an alternative to web.xml.

Example 

// Class
// Implementing WebApplicationInitializer
public class MyWebApplicationInitializer implements WebApplicationInitializer {

  // Servlet container

  public void onStartup(ServletContext container) throws ServletException {
    AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();
    context.register(AppConfig.class);
    context.setServletContext(container);

    // Servlet configuration
  }
}
Container 3: XmlWebApplicationContext

Spring MVC Web-based application can be configured completely using XML or Java code. Configuring this container is similar to the AnnotationConfigWebApplicationContext container, which implies we can configure it in web.xml or using java code.


// Class
// Implementing WebApplicationInitializer
public class MyXmlWebApplicationInitializer implements WebApplicationInitializer {

  // Servlet container
  public void onStartup(ServletContext container) throws ServletException {
    XmlWebApplicationContext context = new XmlWebApplicationContext();
    context.setConfigLocation("/WEB-INF/spring/applicationContext.xml");
    context.setServletContext(container);

    // Servlet configuration
  }
}
Container 4: FileSystemXmlApplicationContext

FileSystemXmlApplicationContext is used to load XML-based Spring Configuration files from the file system or from URL. We can get the application context using Java code. It is useful for standalone environments and test harnesses. The following code shows how to create a container and use the XML as metadata information to load the beans.

Illustration:

String path = "Documents/demoProject/src/main/resources/applicationcontext/student-bean-config.xml";

ApplicationContext context = new FileSystemXmlApplicationContext(path);
AccountService accountService = context.getBean("studentService", StudentService.class);
Container 5: ClassPathXmlApplicationContext

FileSystemXmlApplicationContext is used to load XML-based Spring Configuration files from the classpath. We can get the application context using Java code. It is useful for standalone environments and test harnesses. The following code shows how to create a container and use the XML as metadata information to load the beans.

Illustration:

ApplicationContext context = new ClassPathXmlApplicationContext("applicationcontext/student-bean-config.xml");
StudentService studentService = context.getBean("studentService", StudentService.class);




Q27	What is the difference between XML and Java Configurations for Spring?	
Spring Framework is most popular Java IOC framework. The core features of Spring Framework - IOC/Dependency Injection - are provided by Application Context. (Basic version is the Bean Factory)

Application Context (and Bean Factory) takes care of the bean life cycle and wiring up dependencies other than a host of other features.

Spring Beans can be defined in XML and Java Configurations. We would want to be able to load both these configurations from an Application Context.

In this guide, we look at how to load beans from XML and Java configuration files into an application context in a Spring Boot Application.


Problem 28	How do you choose between XML and Java
Configurations for Spring?	
Problem 29	How does Spring do Autowiring?

The Spring framework enables automatic dependency injection. In other words, by declaring all the bean dependencies in a Spring configuration file, Spring container can autowire relationships between collaborating beans. This is called Spring bean autowiring.

To use Java-based configuration in our application, let's enable annotation-driven injection to load our Spring configuration:

@Configuration
@ComponentScan("com.baeldung.autowire.sample")
public class AppConfig {}



Problem 30	What are the different kinds of matching used by
Spring for Autowiring?	

no: It’s the default autowiring mode. It means no autowiring.
byName: The byName mode injects the object dependency according to name of the bean. In such case, property name and bean name should be same. It internally calls setter method.
byType: The byType mode injects the object dependency according to type. So it can have different property name and bean name. It internally calls setter method.
constructor: The constructor mode injects the dependency by calling the constructor of the class. It calls the constructor having large number of parameters.
autodetect: In this mode, Spring first tries to autowire by constructor. If this fails, it tries to autowire by using byType.

Problem 31	How do you debug problems with Spring Framework? (NoUniqueBeanDefinitionException NoSuchBeanDefinitionException)	

The most common cause of this exception is simply trying to inject a bean that isn't defined.

For example, BeanB is wiring in a collaborator, BeanA:

@Component
public class BeanA {

    @Autowired
    private BeanB dependency;
    //...
}
Copy
Now if the dependency BeanB is not defined in the Spring Context, the bootstrap process will fail with the no such bean definition exception:

org.springframework.beans.factory.NoSuchBeanDefinitionException: 
No qualifying bean of type [com.baeldung.packageB.BeanB]
  found for dependency: 
expected at least 1 bean which qualifies as
  autowire candidate for this dependency. 
Dependency annotations: 
  {@org.springframework.beans.factory.annotation.Autowired(required=true)}
Copy
The reason is clearly indicated by Spring: expected at least 1 bean which qualifies as autowire candidate for this dependency.

One reason BeanB may not exist in the context — if beans are picked up automatically by classpath scanning, and if BeanB is correctly annotated as a bean (@Component, @Repository, @Service, @Controller, etc.) — is that it may be defined in a package that is not scanned by Spring:

package com.baeldung.packageB;
@Component
public class BeanB { ...}
Copy
And the classpath scanning may be configured as follows:

@Configuration
@ComponentScan("com.baeldung.packageA")
public class ContextWithJavaConfig {
    ...
}
Copy
If beans are not automatically scanned but instead defined manually, then BeanB is simply not defined in the current Spring Context.


Q22	What is @Primary?

Spring @Primary annotation is used to give a higher preference to the marked bean when multiple beans of the same type exist.

Spring, by default, auto-wires by type. And so, when Spring attempts to autowire and there are multiple beans of the same type, we’ll get a NoUniqueBeanDefinitionException:

To solve this, we can choose to use Spring @Primary annotation, thereby marking one bean to be the primary one.

@Configuration
public class UniversityConfig {
 
    @Bean
    @Primary
    public Person student() {
        return new Student();
    }
 
    @Bean
    public Person teacher() {
        return new Teacher();
    }
}

Q23	What is @Qualifier?

There may be a situation when you create more than one bean of the same type and want to wire only one of them with a property. In such cases, you can use the @Qualifier annotation along with @Autowired to remove the confusion by specifying which exact bean will be wired. Following is an example to show the use of @Qualifier annotation.

Q24	What is CDI (Contexts and Dependency Injection)?

	CDI (Contexts and Dependency Injection) is a standard dependency injection framework included in Java EE 6 and higher.
It allows us to manage the lifecycle of stateful components via domain-specific lifecycle contexts and inject components (services) into client objects in a type-safe way.

Problem 25	What is Model 1 architecture ?
Problem 26	What is Model 2 architecture ?
Problem 27	What is Model 2 Front Controller architecture?
Problem 28	Can you show an example controller method in
Spring MVC?	
Problem 29	Can you explain a simple flow in Spring MVC?
Problem 30	What is a ViewResolver?
Problem 31	Model vs ModelView
Problem 32	What is a RequestMapping?
Problem 33	What is Dispatcher Servlet?
Problem 34	How do you set up Dispatcher Servlet?
Problem 35	What is a form backing object?
Problem 36	How is validation done using Spring MVC?
Problem 37	What is BindingResult?
Problem 38	How do you map validation results to your view?
Problem 39	What are Spring Form Tags ?
Problem 40	What is a Path Variable?
Problem 41	What is a Model Attribute?
Problem 42	What is a Session Attribute?
Spring JDBC & JPA
Problem	Questions
Problem 1	What is Spring JDBC? How is different from JDBC?
Problem 2	What is a JdbcTemplate?
Problem 3	What is a RowMapper?
Problem 4	What is JPA?
Problem 5	What is Hibernate?
Problem 6	How do you define an entity in JPA?
Problem 7	What is an Entity Manager?
Problem 8	What is a Persistence Context?
Problem 9	How do you map relationships in JPA?
Problem 10	What are the different types of relationships in JPA?
Problem 11	How do you define One to One Mapping in JPA?
Problem 12	How do you define One to Many Mapping in JPA?
Problem 13	How do you define Many to Many Mapping in JPA?
Problem 14	How do you define a datasource in a Spring Context?
Problem 15	What is the use of persistence.xml
Problem 16	How do you configure Entity Manager Factory and
Transaction Manager?	
Problem 17	How do you define transaction management for
Spring – Hibernate integration?	
Problem 18	What is Spring Data?
Problem 19	What is the need for Spring Data?
Problem 20	What is Spring Data JPA?
Problem 21	What is a CrudRepository?
Problem 22	What is a PagingAndSortingRepository?
Notes

Exceptional Handling & Versioning
Problem	Questions
Problem 1	How do you implement Exception Handling for
RESTFul Web Services?	
Problem 2	What are the different error status that you would
return in RESTful Web Services?	
Problem 3	How would you implement them using Spring Boot?
Problem 4	How do you handle Validation Errors with RESTful
Web Services?	
Problem 5	Why do we need Versioning for RESTful Web
Services?	
Problem 6	What are the versioning options that are available?
Problem 7	How do you implement Versioning for RESTful Web
Services?
