1) What is Loose Coupling?

Loose coupling : In simple words, loose coupling means they are mostly independent. If the only knowledge that class A has about class B, is what class B has exposed through its interface, then class A and class B are said to be loosely coupled. In order to over come from the problems of tight coupling between objects, spring framework uses dependency injection mechanism with the help of POJO/POJI model and through dependency injection its possible to achieve loose coupling.
Example : If you change your shirt, then you are not forced to change your body – when you can do that, then you have loose coupling. When you can’t do that, then you have tight coupling. The examples of Loose coupling are Interface, JMS.
// Java program to illustrate 
// loose coupling concept
public interface Topic
{
    void understand();
}
class Topic1 implements Topic {
	public void understand()
    	{
        	System.out.println("Got it");
    	}
} class Topic2 implements Topic {
	public void understand()
    	{
        	System.out.println("understand");
    	}
}public class Subject {
	public static void main(String[] args)
    	{
        	Topic t = new Topic1();
        	t.understand();
    	}
}

2) What is Dependency?

A typical Java application will have three layers in its architecture: web, business and data.

The web layer
The business layer
The data layer
In the above scenario:

Web Layer depends on Business Layer. The business layer is a dependency for the web layer.
Business layer depends on Data Layer. The data layer is a dependency for the business layer.

3) What is IOC (Inversion of Control)?
In general, when a class depends on another class then the dependent class creates the object of its
dependency class directly, and then uses(call) its methods, it is called the dependency object created in the main control.
But if some external entity is taking care of creating the dependency object then we say that control is inverted to some external entity, this is called Inversion of Control (IOC).

4) What is Dependency Injection?
Dependency Injection is a fundamental aspect of the Spring framework, through which the Spring container “injects” objects into other objects or “dependencies”.

Simply put, this allows for loose coupling of components and moves the responsibility of managing components onto the container.

5) Can you give few examples of Dependency Injection ?
Example Car Class might need a reference to an Engine class . These required classe are called dependencies and in the example the car class is dependent on having an instance of the  engine class to run.

6) What is Auto Wiring?
Autowiring feature of spring framework enables you to inject the object dependency implicitly. It internally uses setter or constructor injection.
Autowiring can't be used to inject primitive and string values. It works with reference only.
1)	no:-		It is the default autowiring mode. It means no autowiring bydefault.
2)	byName:-	The byName mode injects the object dependency according to name of the bean. In such case, property name and bean name must be same. It 			internally calls setter method.
3)	byType:-	The byType mode injects the object dependency according to type. So property name and bean name can be different. It internally calls setter 			     method.
4)	constructor:-	The constructor mode injects the dependency by calling the constructor of the class. It calls the constructor having large number of 				parameters.
5)	autodetect:-	It is deprecated since Spring 3.

7) What are the important roles of an IOC Container?
	The IoC container is responsible to instantiate, configure and assemble the objects. The IoC container gets informations from the XML file and works 		accordingly. The main tasks performed by IoC container are:
	1) to instantiate the application class
	2) to configure the object
	3) to assemble the dependencies between the objects
	
	There are two types of IoC containers. They are:

	BeanFactory
	ApplicationContext

8) 	What are Bean Factory and Application Context?
	Spring Framework provides two of the most fundamental and important packages, they are the org.springframework.beans and org.springframework.context packages. 		Code in these packages provides the basis for Spring’s Inversion of Control/Dependency Injection features. Spring containers are responsible for creating bean 		objects and injecting them into the classes. The two containers are namely,

	BeanFactory(I) – Available in org.springframework.beans.factory package.
	ApplicationContext(I) – Available in rg.springframework.context package.
	
	The BeanFactory Interface
	This is the root interface for accessing a Spring bean container. It is the actual container that instantiates, configures, and manages a number of beans. 	   These beans collaborate with one another and thus have dependencies between themselves. These dependencies are reflected in the configuration data used by the 	  BeanFactory. This interface is implemented by the objects that hold a number of bean definitions, each uniquely identified by a String name. The most common 	         implementation class used for this BeanFactory is XmlBeanFactory available in org.springframework.beans.factory.xml package. 


	Note: BeanFactory is deprecated from Spring 3.0.

	Example code:
	ClassPathResource resource = new ClassPathResource("beans.xml");
	XmlBeanFactory factory = new XmlBeanFactory(resource);
 
 

	The ApplicationContext Interface
 

	This interface is designed on top of the BeanFactory interface. The ApplicationContext interface is the advanced container that enhances BeanFactory 		functionality in a more framework-oriented style. While the BeanFactory provides basic functionality for managing and manipulating beans, often in a 		programmatic way, the ApplicationContext provides extra functionality like MessageSource, Access to resources, Event propagation to beans, Loading of multiple 		(hierarchical) contexts etc. There are so many implementation classes that can be used such as ClassPathXmlApplicationContext,FileSystemXmlApplicationContext, 		AnnotationConfigWebApplicationContext etc.


	Example code:
	ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
	
	
9) 	Can you compare Bean Factory with Application Context?

	BeanFactory loads beans on-demand, while ApplicationContext loads all beans at startup. Thus, BeanFactory is lightweight as compared to ApplicationContext. 	    Let's understand it with an example.
	
	public class Student {
    public static boolean isBeanInstantiated = false;

    public void postConstruct() {
        setBeanInstantiated(true);
    }
}

10) How do you create an application context with Spring?

Step 1: Creating a Spring Project using Spring Initializer as pictorially depicted below.



Step 2: Create Student class under com.gfg.demo.domain and AppConfig class under com.gfg.demo.config packages. The AppConfig is the configuration class that contains all the Java beans configured using Java Based Configuration. The Student class is the POJO class.

Class 1: AppConfig class
@Configuration

// Class
public class AppConfig {

  @Bean

  // Method
  public Student student() {

    return new Student(1, "Geek");
  }
}
Class 2: Student class
// Class
public class Student {

  // member variables
  private int id;
  private String name;

  // Constructor 1
  public Student() {}

  // Constructor 2
  public Student(int id, String name) {
    this.id = id;
    this.name = name;
  }

  // Method of this class
  // @Override
  public String toString() {

    return "Student{" + "id=" + id + ", name='" + name + '\'' + '}';
  }
}
Step 3: Now the Main Application class at the root contains the creation of a container.

// Class
// @SpringBootApplication
public class DemoApplication {

  // Main driver method
  public static void main(String[] args) {

    // SpringApplication.run(DemoApplication.class, args);

    // Creating its object
    ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
    Student student = context.getBean(Student.class);

    // Print and display
    System.out.println(student);
  }
}
Step 4: The SpringApplication.run() method is provided by default in the main class when the SpringBoot project is created. It creates the container, creates beans, manages dependency injection and life cycle of those beans. This is done using @SpringBootApplication annotation.


Q11 How does Spring know where to search for Components or Beans?


If you understand Component Scan, you understand Spring.

Spring is a dependency injection framework. It is all about beans and wiring in dependencies.

The first step of defining Spring Beans is by adding the right annotation — @Component or @Service or @Repository.

However, Spring does not know about the bean unless it knows where to search for it.

This part of “telling Spring where to search” is called a Component Scan.

You define the packages that have to be scanned.

Once you define a Component Scan for a package, Spring would search the package and all its sub packages for components/beans.

Defining a Component Scan

If you are using Spring Boot, check the configuration in Approach 1.
If you are doing a JSP/Servlet or a Spring MVC application without using Spring Boot, use Approach 2.
Approach 1: Component Scan in a Spring Boot Project

If your other package hierarchies are below your main app with the @SpringBootApplication annotation, you’re covered by the implicit Component Scan. If there are beans/components in other packages that are not sub-packages of the main package, you should manually add them as @ComponentScan

Consider below class

package com.in28minutes.springboot.basics.springbootin10steps;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ConfigurableApplicationContext;
@SpringBootApplication
public class SpringbootIn10StepsApplication {
    public static void main(String[] args) {
        ApplicationContext applicationContext =
            SpringApplication.run(SpringbootIn10StepsApplication.class, args);
        for (String name: applicationContext.getBeanDefinitionNames()) {
            System.out.println(name);
        }
    }
}
@SpringBootApplication is defined in the SpringbootIn10StepsApplication class which is in the package com.in28minutes.springboot.basics.springbootin10steps

@SpringBootApplication defines an automatic Component Scan on the package com.in28minutes.springboot.basics.springbootin10steps.

You are fine if all your components are defined in the above package or a sub-package of it.

However, let’s say one of the components is defined in package com.in28minutes.springboot.somethingelse

In this case, you would need to add the new package into Component Scan.

You have two options:

Option 1:

@ComponentScan(“com.in28minutes.springboot”)
@SpringBootApplication
public class SpringbootIn10StepsApplication {...}
Option 2:: Define as array

@ComponentScan({"com.in28minutes.springboot.basics.springbootin10steps","com.in28minutes.springboot.somethingelse"})
@SpringBootApplication
public class SpringbootIn10StepsApplication {...}
Approach 2: Non-Spring Boot Project

Option 1:

@ComponentScan(“com.in28minutes)
@Configuration
public class SpringConfiguration {...}
Option 2:

@ComponentScan({"com.in28minutes.package1","com.in28minutes.package2"})
@Configuration
public class SpringConfiguration {...}
XML application context:

<context:component-scan base-package="com.in28minutes" />
Specific multiple packages:

<context:component-scan base-package="com.in28minutes.package1, com.in28minutes.package2" />


Q12 What is a component scan?
When developing Spring Boot applications, you need to tell the Spring Framework where to look for Spring components. Using component scan is one method of asking Spring to detect Spring managed components. Spring needs the information to locate and register all the Spring components with the application context when the application starts.

Spring can auto scan, detect, and instantiate components from pre-defined project packages. It can auto scan all classes annotated with the stereotype annotations @Component, @Controller, @Service, and @Repository


Q13 How do you define a component scan in XML and
Java Configurations?

To autodetect these classes and register the corresponding beans, you need to include the following element in XML, where the base-package element is a common parent package for the two classes. (Alternatively, you can specify a comma-separated list that includes the parent package of each class.)

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context-3.0.xsd">
               
     <context:component-scan base-package="org.example"/>
     
</beans>


With Spring, we use the @ComponentScan annotation along with the @Configuration annotation to specify the packages that we want to be scanned. @ComponentScan without arguments tells Spring to scan the current package and all of its sub-packages.

Let's say we have the following @Configuration in com.baeldung.componentscan.springapp package:


freestar
@Configuration
@ComponentScan
public class SpringComponentScanApp {
    private static ApplicationContext applicationContext;

    @Bean
    public ExampleBean exampleBean() {
        return new ExampleBean();
    }

    public static void main(String[] args) {
        applicationContext = 
          new AnnotationConfigApplicationContext(SpringComponentScanApp.class);

        for (String beanName : applicationContext.getBeanDefinitionNames()) {
            System.out.println(beanName);
        }
    }
}


Q14 How is it done with Spring Boot?

Already answered above.

Q15 What does @Component signify?

Spring Component
In layman terms, a Component is responsible for some operations. Spring framework provides three other specific annotations to be used when marking a class as Component.

Service: Denotes that the class provides some services. Our utility classes can be marked as Service classes.
Repository: This annotation indicates that the class deals with CRUD operations, usually it’s used with DAO implementations that deal with database tables.
Controller: Mostly used with web applications or REST web services to specify that the class is a front controller and responsible to handle user request and return appropriate response.
Note that all these four annotations are in package org.springframework.stereotype and part of spring-context jar. Most of the time our component classes will fall under one of its three specialized annotations, so you may not use @Component annotation a lot.

Spring Component Example
Let’s create a very simple Spring maven application to showcase the use of Spring Component annotation and how Spring autodetects it with annotation-based configuration and classpath scanning. Create a maven project and add following spring core dependency.

<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-context</artifactId>
	<version>5.0.6.RELEASE</version>
</dependency>
That’s all we need to get the spring framework core features. Let’s create a simple component class and mark it with @Component annotation.

package com.journaldev.spring;

import org.springframework.stereotype.Component;

@Component
public class MathComponent {

	public int add(int x, int y) {
		return x + y;
	}
}
Now we can create an annotation based spring context and get the MathComponent bean from it.

package com.journaldev.spring;

import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class SpringMainClass {

	public static void main(String[] args) {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		context.scan("com.journaldev.spring");
		context.refresh();

		MathComponent ms = context.getBean(MathComponent.class);

		int result = ms.add(1, 2);
		System.out.println("Addition of 1 and 2 = " + result);

		context.close();
	}

}


Q16 What does @Autowired signify?

The @Autowired annotation provides more fine-grained control over where and how autowiring should be accomplished. The @Autowired annotation can be used to autowire bean on the setter method just like @Required annotation, constructor, a property or methods with arbitrary names and/or multiple arguments.


Q17 What’s the difference Between @Controller,@Component, @Repository, and @Service	
Annotations in Spring?

The major difference between these stereotypes is that they are used for different classifications. When we annotate a class for auto-detection, we should use the respective stereotype.

Now let's go through them in more detail.

1)  @Controller
The @Controller annotation indicates that a particular class serves the role of a controller. Spring Controller annotation is typically used in combination with annotated handler methods based on the @RequestMapping annotation. It can be applied to classes only. It’s used to mark a class as a web request handler. 

2) @Component
We can use @Component across the application to mark the beans as Spring's managed components. Spring will only pick up and register beans with @Component, and doesn't look for @Service and @Repository in general.

They are registered in ApplicationContext because they are annotated with @Component:

@Component
public @interface Service {
}
Copy
@Component
public @interface Repository {
}
Copy
@Service and @Repository are special cases of @Component. They are technically the same, but we use them for the different purposes.

3) @Repository
@Repository’s job is to catch persistence-specific exceptions and re-throw them as one of Spring’s unified unchecked exceptions.

For this, Spring provides PersistenceExceptionTranslationPostProcessor, which we are required to add in our application context (already included if we're using Spring Boot):

<bean class=
  "org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor"/>
Copy
This bean post processor adds an advisor to any bean that’s annotated with @Repository.

4) @Service
We mark beans with @Service to indicate that they're holding the business logic. Besides being used in the service layer, there isn't any other special use for this annotation.

4 Conclusion
In this article, we learned about the differences between the @Component, @Repository, and @Service annotations. We examined each annotation separately to understand their areas of use.

In conclusion, it's always a good idea to choose the annotation based on their layer conventions.


Q18  what is the default scope of a bean?

The default scope for the bean is a singleton, like the example below, in which we haven't explicitly given a scope. Singleton means that the Spring container creates only one instance of the bean, and cached in memory, and all the requests for that bean will return a shared reference to the same bean.


Q19	Are Spring beans thread safe?
	Is Spring singleton thread safe? The short answer is: no, it isn't. And you probably already know why. It's because of the long life cycle of singleton beans.


Q20  What are the other scopes available?

singleton.
prototype.
request.
session.
application.
websocket.

Singleton
When we define a bean with the singleton scope, the container creates a single instance of that bean; all requests for that bean name will return the same object, which is cached. Any modifications to the object will be reflected in all references to the bean. This scope is the default value if no other scope is specified.

Prototype
A bean with the prototype scope will return a different instance every time it is requested from the container. It is defined by setting the value prototype to the @Scope annotation in the bean definition:

Request & Session 
The request scope creates a bean instance for a single HTTP request, while the session scope creates a bean instance for an HTTP Session.
The application scope creates the bean instance for the lifecycle of a ServletContext, and the websocket scope creates it for a particular WebSocket session.

Application scope
The application scope creates the bean instance for the lifecycle of a ServletContext.

This is similar to the singleton scope, but there is a very important difference with regards to the scope of the bean.
When beans are application scoped, the same instance of the bean is shared across multiple servlet-based applications running in the same ServletContext, while singleton scoped beans are scoped to a single application context only.

Webscoket Scope

When first accessed, WebSocket scoped beans are stored in the WebSocket session attributes. The same instance of the bean is then returned whenever that bean is accessed during the entire WebSocket session.
We can also say that it exhibits singleton behavior, but limited to a WebSocket session only.


Q21 How is Spring’s singleton bean different from Gang of Four Singleton Pattern?

Spring Singleton is very different from Singleton pattern. Spring guarantees to create only one bean instance for given bean id definition per container.Singleton pattern ensures that one and only one instance is created per ClassLoader. 

Q22 What are the different types of dependency
Spring provides an IoC container which is responsible for instantiating, configuring and managing the lifecycle of Spring beans. In Spring, any POJO is referred to as a Spring bean.

The Spring ApplicationContext interface represents its IoC container and we have several implementation classes available. Some of these include ClassPathXmlApplicationContext, FileSystemXmlApplicationContext, and WebApplicationContext.

Let’s instantiate the Spring container using ClassPathXmlApplicationContext:
ApplicationContext appContext 
  = new ClassPathXmlApplicationContext("applicationContext.xml");

Here, the applicationContext.xml is the file that holds the metadata required to assemble beans at runtime.
Spring supports three types of dependency injection:

1. Constructor-Based Injection:
In a constructor-based injection, Spring will use the matching constructor to resolve and inject the dependency.

We can either configure the beans in applicationContext.xml:
<bean id="address" class="com.programmergirl.domain.Address"/>
<bean id="person" class="com.programmergirl.domain.Person">
    <constructor-arg ref="address"/>
</bean>

Or, we can enable the <component-scan/> in our applicationContext.xml:
<context:component-scan base-package="com.programmergirl.domain" />

On enabling component scan, we can make the Spring configurations using the annotations. Our classes would then look like:
package com.programmergirl.domain;
@Component
public class Person {
    private Address address;
    @Autowired
    public Person(Address address) {
        this.address = address;
    }
}
package com.programmergirl.domain;
@Component
public class Address {
   ...
}

Spring, by default, wires the beans by their type. If there are more than one beans of the same type, we can use @Qualifier annotation to reference a bean by its name:
@Component
public class Person {
    private Address address;
    @Autowired
    @Qualifier("address1")
    public void setAddress(Address address) {
        this.address = address;
    }
}

Assuming we have two Address beans – address1 and address2, our address1 bean will be injected into Person class while dependency resolution.
2. Setter Injection:
Setter-based dependency injection is achieved through the setter method on the bean after instantiating it using a no-arg constructor or no-argument static factory.

We can configure it using XML as:
<bean id="address" class="com.programmergirl.domain.Address"/>
<bean id="person" class="com.programmergirl.domain.Person">
    <property name="address" ref="address"/>
</bean>

On the other hand, when using annotations, we’ll have:
@Component
public class Person {
    
    private Address address;
    ...
    @Autowired
    public void setAddress(Address address) {
        this.address = address;
    }
    
}
3. Property-Based Injection:
We can also inject dependencies using fields or properties of a class. To do so, we can simply use the @Autowired annotation over the field:
@Component
public class Person {
    @Autowired
    private Address address;
    ...
}


Q23 What is setter injection?

Setter Dependency Injection (SDI): This is the simpler of the two DI methods. In this, the DI will be injected with the help of setter and/or getter methods. Now to set the DI as SDI in the bean, it is done through the bean-configuration file For this, the property to be set with the SDI is declared under the <property> tag in the bean-config file.

Q24 What is constructor injection?

Constructor Dependency Injection (CDI): In this, the DI will be injected with the help of constructors. Now to set the DI as CDI in bean, it is done through the bean-configuration file For this, the property to be set with the CDI is declared under the <constructor-arg> tag in the bean-config file.

Q25  How do you choose between setter and constructor injections?

When to use Setter Injection and when to use Constructor Injection?
If there is only one property in a spring bean class then use constructor injection as constructor executes before methods constructor injection will be faster than setter injection. 

If spring bean class is having more than one property then it is better to use setter injection because it reduces burden on the programmer. Setter injection reduces burden on the programmer because programmer need not to worry about index, type of parameters as in the case of constructor injection. 

It is not mandatory that all properties must be configured for injection. Properties can be left with their default values. 


Q26 What are the different options available to create Application Contexts for Spring?	
	
ApplicationContext Implementation Classes

There are different types of Application containers provided by Spring for different requirements as listed below which later onwards are described alongside with declaration, at lastly providing an example to get through the implementation part with the pictorial aids. Containers are as follows:


AnnotationConfigApplicationContext container 
AnnotationConfigWebApplicationContext
XmlWebApplicationContext
Container 1: AnnotationConfigApplicationContext

AnnotationConfigApplicationContext class was introduced in Spring 3.0. It accepts classes annotated with @Configuration, @Component, and JSR-330 compliant classes. The constructor of AnnotationConfigApplicationContext accepts one or more classes. For example, in the below declaration, two Configuration classes Appconfig and AppConfig1 are passed as arguments to the constructor. The beans defined in later classes will override the same type and name beans in earlier classes when passed as arguments. For example, AppConfig and AppConfig1 have the same bean declaration. The bean defined in AppConfig1 overrides the bean in AppConfig.

Syntax: Declaration

ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class, AppConfig1.class);
Note: Add the following to the properties file in the IDE to allow the spring to override beans.

spring.main.allow-bean-definition-overriding=true
Container 2: AnnotationConfigWebApplicationContext

AnnotationConfigWebApplicationContext class was introduced in Spring 3.0. It is similar to AnnotationConfigApplicationContext for a web environment. It accepts classes annotated with @Configuration, @Component, and JSR-330 compliant classes. These classes can be registered via register() method or passing base packages to scan() method. This class may be used when we configure ContextLoaderListener servlet listener or a DispatcherServlet in a web.xml. From Spring 3.1, this class can be instantiated and injected to DispatcherServlet using java code by implementing WebApplicationInitializer, an alternative to web.xml.

Example 

// Class
// Implementing WebApplicationInitializer
public class MyWebApplicationInitializer implements WebApplicationInitializer {

  // Servlet container

  public void onStartup(ServletContext container) throws ServletException {
    AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();
    context.register(AppConfig.class);
    context.setServletContext(container);

    // Servlet configuration
  }
}
Container 3: XmlWebApplicationContext

Spring MVC Web-based application can be configured completely using XML or Java code. Configuring this container is similar to the AnnotationConfigWebApplicationContext container, which implies we can configure it in web.xml or using java code.


// Class
// Implementing WebApplicationInitializer
public class MyXmlWebApplicationInitializer implements WebApplicationInitializer {

  // Servlet container
  public void onStartup(ServletContext container) throws ServletException {
    XmlWebApplicationContext context = new XmlWebApplicationContext();
    context.setConfigLocation("/WEB-INF/spring/applicationContext.xml");
    context.setServletContext(container);

    // Servlet configuration
  }
}
Container 4: FileSystemXmlApplicationContext

FileSystemXmlApplicationContext is used to load XML-based Spring Configuration files from the file system or from URL. We can get the application context using Java code. It is useful for standalone environments and test harnesses. The following code shows how to create a container and use the XML as metadata information to load the beans.

Illustration:

String path = "Documents/demoProject/src/main/resources/applicationcontext/student-bean-config.xml";

ApplicationContext context = new FileSystemXmlApplicationContext(path);
AccountService accountService = context.getBean("studentService", StudentService.class);
Container 5: ClassPathXmlApplicationContext

FileSystemXmlApplicationContext is used to load XML-based Spring Configuration files from the classpath. We can get the application context using Java code. It is useful for standalone environments and test harnesses. The following code shows how to create a container and use the XML as metadata information to load the beans.

Illustration:

ApplicationContext context = new ClassPathXmlApplicationContext("applicationcontext/student-bean-config.xml");
StudentService studentService = context.getBean("studentService", StudentService.class);




Q27	What is the difference between XML and Java Configurations for Spring?	
Spring Framework is most popular Java IOC framework. The core features of Spring Framework - IOC/Dependency Injection - are provided by Application Context. (Basic version is the Bean Factory)

Application Context (and Bean Factory) takes care of the bean life cycle and wiring up dependencies other than a host of other features.

Spring Beans can be defined in XML and Java Configurations. We would want to be able to load both these configurations from an Application Context.

In this guide, we look at how to load beans from XML and Java configuration files into an application context in a Spring Boot Application.


Problem 28	How do you choose between XML and Java
Configurations for Spring?	
Problem 29	How does Spring do Autowiring?

The Spring framework enables automatic dependency injection. In other words, by declaring all the bean dependencies in a Spring configuration file, Spring container can autowire relationships between collaborating beans. This is called Spring bean autowiring.

To use Java-based configuration in our application, let's enable annotation-driven injection to load our Spring configuration:

@Configuration
@ComponentScan("com.baeldung.autowire.sample")
public class AppConfig {}



Problem 30	What are the different kinds of matching used by
Spring for Autowiring?	

no: It’s the default autowiring mode. It means no autowiring.
byName: The byName mode injects the object dependency according to name of the bean. In such case, property name and bean name should be same. It internally calls setter method.
byType: The byType mode injects the object dependency according to type. So it can have different property name and bean name. It internally calls setter method.
constructor: The constructor mode injects the dependency by calling the constructor of the class. It calls the constructor having large number of parameters.
autodetect: In this mode, Spring first tries to autowire by constructor. If this fails, it tries to autowire by using byType.

Problem 31	How do you debug problems with Spring Framework? (NoUniqueBeanDefinitionException NoSuchBeanDefinitionException)	

The most common cause of this exception is simply trying to inject a bean that isn't defined.

For example, BeanB is wiring in a collaborator, BeanA:

@Component
public class BeanA {

    @Autowired
    private BeanB dependency;
    //...
}
Copy
Now if the dependency BeanB is not defined in the Spring Context, the bootstrap process will fail with the no such bean definition exception:

org.springframework.beans.factory.NoSuchBeanDefinitionException: 
No qualifying bean of type [com.baeldung.packageB.BeanB]
  found for dependency: 
expected at least 1 bean which qualifies as
  autowire candidate for this dependency. 
Dependency annotations: 
  {@org.springframework.beans.factory.annotation.Autowired(required=true)}
Copy
The reason is clearly indicated by Spring: expected at least 1 bean which qualifies as autowire candidate for this dependency.

One reason BeanB may not exist in the context — if beans are picked up automatically by classpath scanning, and if BeanB is correctly annotated as a bean (@Component, @Repository, @Service, @Controller, etc.) — is that it may be defined in a package that is not scanned by Spring:

package com.baeldung.packageB;
@Component
public class BeanB { ...}
Copy
And the classpath scanning may be configured as follows:

@Configuration
@ComponentScan("com.baeldung.packageA")
public class ContextWithJavaConfig {
    ...
}
Copy
If beans are not automatically scanned but instead defined manually, then BeanB is simply not defined in the current Spring Context.


Q22	What is @Primary?

Spring @Primary annotation is used to give a higher preference to the marked bean when multiple beans of the same type exist.

Spring, by default, auto-wires by type. And so, when Spring attempts to autowire and there are multiple beans of the same type, we’ll get a NoUniqueBeanDefinitionException:

To solve this, we can choose to use Spring @Primary annotation, thereby marking one bean to be the primary one.

@Configuration
public class UniversityConfig {
 
    @Bean
    @Primary
    public Person student() {
        return new Student();
    }
 
    @Bean
    public Person teacher() {
        return new Teacher();
    }
}

Q23	What is @Qualifier?

There may be a situation when you create more than one bean of the same type and want to wire only one of them with a property. In such cases, you can use the @Qualifier annotation along with @Autowired to remove the confusion by specifying which exact bean will be wired. Following is an example to show the use of @Qualifier annotation.

Q24	What is CDI (Contexts and Dependency Injection)?

	CDI (Contexts and Dependency Injection) is a standard dependency injection framework included in Java EE 6 and higher.
It allows us to manage the lifecycle of stateful components via domain-specific lifecycle contexts and inject components (services) into client objects in a type-safe way.

Q25	What is Model 1 architecture ?
	Before developing the web applications, we need to have idea about design models. There are two types of programming models (design models)

	1) Model 1 Architecture
	2) Model 2 (MVC) Architecture
	
	Model 1 Architecture
	Servlet and JSP are the main technologies to develop the web applications.

	Servlet was considered superior to CGI. Servlet technology doesn't create process, rather it creates thread to handle request. The advantage of creating thread 	over process is that it doesn't allocate separate memory area. Thus many subsequent requests can be easily handled by servlet.

	Problem in Servlet technology Servlet needs to recompile if any designing code is modified. It doesn't provide separation of concern. Presentation and Business 	logic are mixed up.
	
	JSP overcomes almost all the problems of Servlet. It provides better separation of concern, now presentation and business logic can be easily separated. You 	     don't need to redeploy the application if JSP page is modified. JSP provides support to develop web application using JavaBean, custom tags and JSTL so that 	  we can put the business logic separate from our JSP that will be easier to test and debug.
	
	As you can see in the above figure, there is picture which show the flow of the model1 architecture.

	Browser sends request for the JSP page JSP accesses Java Bean and invokes business logic Java Bean connects to the database and get/save data Response is sent 	       to the browser which is generated by JSP Advantage of Model 1 Architecture Easy and Quick to develop web application
	Disadvantage of Model 1 Architecture
	
	Navigation control is decentralized since every page contains the logic to determine the next page. If JSP page name is changed that is referred by other 	  pages, we need to change it in all the pages that leads to the maintenance problem.
	Time consuming You need to spend more time to develop custom tags in JSP. So that we don't need to use scriptlet tag.
	Hard to extend It is better for small applications but not for large applications.
	
	Disadvantage of Model 1 Architecture
	Navigation control is decentralized since every page contains the logic to determine the next page. If JSP page name is changed that is referred by other 	  pages, we need to change it in all the pages that leads to the maintenance problem.
	Time consuming You need to spend more time to develop custom tags in JSP. So that we don't need to use scriptlet tag.
	Hard to extend It is better for small applications but not for large applications.

	Q26	What is Model 2 architecture ?
		Model 2 (MVC) Architecture
		
		Model 2 is based on the MVC (Model View Controller) design pattern. The MVC design pattern consists of three modules model, view and controller.

		Model The model represents the state (data) and business logic of the application.

		View The view module is responsible to display data i.e. it represents the presentation.

		Controller The controller module acts as an interface between view and model. It intercepts all the requests i.e. receives input and commands to Model/ 		View to change accordingly.

		mvc architecture
		Advantage of Model 2 (MVC) Architecture
		Navigation control is centralized Now only controller contains the logic to determine the next page.
		Easy to maintain
		Easy to extend
		Easy to test
		Better separation of concerns
		
		Disadvantage of Model 2 (MVC) Architecture
		We need to write the controller code self. If we change the controller code, we need to recompile the class and redeploy the application.
		
Q27	What is Model 2 Front Controller architecture?

	The front controller design pattern means that all requests that come for a resource in an application will be handled by a single handler and then dispatched to the appropriate handler for that type of request. The front controller may use other helpers to achieve the dispatching mechanism.

Controller : The controller is the initial contact point for handling all requests in the system. The controller may delegate to a helper to complete authentication and authorization of a user or to initiate contact retrieval.
View: A view represents and displays information to the client. The view retrieves information from a model. Helpers support views by encapsulating and adapting the underlying data model for use in the display.
Dispatcher: A dispatcher is responsible for view management and navigation, managing the choice of the next view to present to the user, and providing the mechanism for vectoring control to this resource.
Helper : A helper is responsible for helping a view or controller complete its processing. Thus, helpers have numerous responsibilities, including gathering data required by the view and storing this intermediate model, in which case the helper is sometimes referred to as a value bean.

Advantages :

Centralized control : Front controller handles all the requests to the Web application. This implementation of centralized control that avoids using multiple controllers is desirable for enforcing application-wide policies such as users tracking and security.
Thread-safety : A new command object arises when receiving a new request and the command objects are not meant to be thread-safe. Thus, it will be safe in the command classes. Though safety is not guaranteed when threading issues are gathered, codes that act with the command are still thread safe.
Disadvantages :

It is not possible to scale an application using a front controller.
Performance is better if you deal with a single request uniquely.
This article is contributed by Saket Kumar. If you like GeeksforGeeks and would like to contribute, you can also write an article using contribute.geeksforgeeks.org or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.

Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.


Q28	Can you show an example controller method in Spring MVC?	
	Spring Controller
	Spring Controller annotation can be applied on classes only. It’s used to mark a class as a web request handler. It’s mostly used with Spring MVC application.	      Let’s create a simple spring application where we will implement standard MVC controller as well as REST controller. Create a “Dynamic Web Project” in Eclipse and then convert it to Maven project. This will provide us with maven based web application structure and we can build our application on top of it. Below image shows the final project structure of our Spring MVC Controller application.
	<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-webmvc</artifactId>
	<version>5.0.7.RELEASE</version>
</dependency>
<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-web</artifactId>
	<version>5.0.7.RELEASE</version>
</dependency>

<!-- Jackson for REST -->
<dependency>
	<groupId>com.fasterxml.jackson.core</groupId>
	<artifactId>jackson-databind</artifactId>
	<version>2.9.6</version>
</dependency>
Let’s look at the deployment descriptor (web.xml) where we will configure DispatcherServlet servlet as the front controller.

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="https://www.w3.org/2001/XMLSchema-instance" xmlns="https://xmlns.jcp.org/xml/ns/javaee" 
 xsi:schemaLocation="https://xmlns.jcp.org/xml/ns/javaee https://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" id="WebApp_ID" version="3.1">
  <display-name>Spring-Controller</display-name>
  <!-- Add Spring MVC DispatcherServlet as front controller -->
	<servlet>
        <servlet-name>spring</servlet-name>
        <servlet-class>
                org.springframework.web.servlet.DispatcherServlet
        </servlet-class>
        <init-param>
       		<param-name>contextConfigLocation</param-name>
       		<param-value>/WEB-INF/spring-servlet.xml</param-value>
    		</init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>
 
    <servlet-mapping>
        <servlet-name>spring</servlet-name>
        <url-pattern>/</url-pattern> 
    </servlet-mapping>
</web-app>
Finally, we have following spring context file. Here we are configuring our application to be annotation-based and providing root package for scanning spring components. We are also configuring InternalResourceViewResolver bean and providing details of view pages.

<?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns="https://www.springframework.org/schema/mvc"
	xmlns:xsi="https://www.w3.org/2001/XMLSchema-instance" xmlns:beans="https://www.springframework.org/schema/beans"
	xmlns:context="https://www.springframework.org/schema/context"
	xsi:schemaLocation="https://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd
		https://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
		https://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">

	<!-- Enables the Spring MVC @Controller programming model -->
	<annotation-driven />

	<context:component-scan base-package="com.journaldev.spring" />

	<!-- Resolves views selected for rendering by @Controllers to JSP resources 
		in the /WEB-INF/views directory -->
	<beans:bean
		class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<beans:property name="prefix" value="/WEB-INF/views/" />
		<beans:property name="suffix" value=".jsp" />
	</beans:bean>

</beans:beans>
Our configuration XML files are ready, let’s move on to the Controller class now.

package com.journaldev.spring.controller;

import java.text.DateFormat;
import java.util.Date;
import java.util.Locale;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class HomeController {

	@GetMapping("/hello")
	public String home(Locale locale, Model model) {
		Date date = new Date();
		DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG, locale);
		String formattedDate = dateFormat.format(date);
		model.addAttribute("serverTime", formattedDate);
		return "home";
	}

}
We have defined a single request handler method, it’s accepting GET requests with URI “/hello” and returning “home.jsp” page as the response. Notice that we are setting an attribute to the model, which will be used in the home.jsp page. Here is our simple home.jsp page code.

<%@ page language="java" contentType="text/html; charset=UTF-8"
	pageEncoding="UTF-8"%>
<html>
<head>
<title>Home</title>
</head>
<body>
	<h1>Hello world!</h1>

	<p>The time on the server is ${serverTime}.</p>

</body>
</html>
Spring MVC Controller Test
Our conventional servlet based Spring MVC application with a simple controller is ready, just export it as the WAR file and deploy on Tomcat or any other servlet container. Then go to URL https://localhost:8080/Spring-Controller/hello and you should see the following screen as output.


Q29	Can you explain a simple flow in Spring MVC?
	Spring MVC is a Java framework that is used to develop web applications. It is built on a Model-View-Controller (MVC) pattern and possesses all the basic features of a spring framework, such as Dependency Injection, Inversion of Control. The architectural design of a Spring MVC can be used to develop flexible web applications. It basically separates the different aspects of the application, like input logic, UI logic, and business logic. 
	Spring is an open-source that was created to resolve the complexity of an enterprise application development. It has a layered architecture that helps the developers to select the components which can be further used while providing a cohesive framework for the process of application development. Spring framework is flexible as it supports and can be integrated with various technologies like:

It supports the REST style of web services.
Supports transactional management
The developer can interact with different databases.
Can be integrated with Object Relationship frameworks, for instance, iBatis
Containers can resolve the required dependencies as it supports Dependency Integration.
The following article will clear all your doubts about what is Spring MVC, Spring MVC full form and the importance of Spring MVC in Java. Furthermore, it will also shed some light on the differences between Spring MVC and Spring Boot and why the former is preferred over the latter.


Q 30	What is a ViewResolver?
	Spring MVC is a Web MVC Framework for building web applications. In generic all MVC frameworks provide a way of working with views. Spring does that via the ViewResolvers, which enables you to render models in the browser without tying the implementation to specific view technology. Now let’s understand ViewResolver with an example project in STS. 

The Spring MVC framework is comprised of the following components:

Model: A model can be an object or collection of objects which basically contains the data of the application.
View: A view is used for displaying the information to the user in a specific format. Spring supports various technologies like freemarker, velocity, and thymeleaf.
Controller: It contains the logical part of the application. @Controller annotation is used to mark that class as controller.
Front Controller: It remains responsible for managing the flow of the web application. DispatcherServlet acts as a front controller in Spring MVC.
Requirements: Prior to it, certain requirements are needed that are as follows:  

Eclipse (EE version)/STS IDE
Spring JAR Files
Tomcat Apache latest version


Q 31	Model vs ModelView
	What is Model or Domain Model?

Actually, the word "model" has hundreds of meanings in software development, but here we will talk about "model" in the context of a MVC design pattern. I would define a model as an object that we use to send information to the database, to perform business calculations and to render a view. In other words, "model" represents the domain of the application that helps us to save, create, update and delete records. Usually we put all our model classes in the Model folder.

What is ViewModel?

ViewModel in the MVC design pattern is very similar to a "model". The major difference between "Model" and "ViewModel" is that we use a ViewModel only in rendering views. We put all our ViewModel classes in a "ViewModels" named folder, we create this folder.

Understand it with an example
Let's assume we want to implement a view page that will have three textboxes for Username, Password and Re-enter Password. To do this we could design a "Model" as given below:
public class Login  
{  
    public String Username { get; set; }  
    public String Password { get; set; }  
    public String RePassword { get; set; }  
}
For the sake of the view this model works fine. But this is actually an incorrect approach because we are trying to overcrowd the database. I can't see any use of the "RePassword" property in the database.

Now, if we take the advantage of a ViewModel, we can safeguard the database from redundant data. Here's how, design the following "Model" that will be our Domain Model:
 

//this will represent domain of the application  
public class Login  
{  
    public String Username { get; set; }  
    public String Password { get; set; }  
}  
And then following "ViewModel"
//this will help in rendering great views  
public class LoginViewModel  
{  
    public String Username { get; set; }  
    public String Password { get; set; }  
    public String RePassword { get; set; }  
}
Q 32	What is a RequestMapping?
	One of the most important annotations in spring is the @RequestMapping Annotation which is used to map HTTP requests to handler methods of MVC and REST controllers. In Spring MVC applications, the DispatcherServlet (Front Controller) is responsible for routing incoming HTTP requests to handler methods of controllers. When configuring Spring MVC, you need to specify the mappings between the requests and handler methods. To configure the mapping of web requests, we use the @RequestMapping annotation. The @RequestMapping annotation can be applied to class-level and/or method-level in a controller. The class-level annotation maps a specific request path or pattern onto a controller. You can then apply additional method-level annotations to make mappings more specific to handler methods. So let’s understand @RequestMapping Annotation at Method-level and Class level by examples. 


	
Q 33	What is Dispatcher Servlet?
	Dispatcher Servlet
DispatcherServlet acts as the Front Controller for Spring-based web applications. So now what is Front Controller? So it is pretty simple. Any request is going to come into our website the front controller is going to stand in front and is going to accept all the requests and once the front controller accepts that request then this is the job of the front controller that it will make a decision that who is the right controller to handle that request. For example, refer to the below image. Suppose we have a website called student.com and the client is make a request to save student data by hitting the following URL student.com/save and its first come to the front controller and once the front controller accepts that request it is going to assign to the Controller_1 as this controller handle the request for /save operation. Then it is going to return back the response to the Client. 


Q 34	How do you set up Dispatcher Servlet?
	
	Setting Up Dispatcher Servlet
Now let’s see how can we set up DispatcherServlet in our Spring MVC project.  

Note: We are going to use Spring Tool Suite 4 IDE for this project. Please refer to this article to install STS in your local machine How to Download and Install Spring Tool Suite (Spring Tools 4 for Eclipse) IDE? 

Step 1: Create a Dynamic Web Project in your STS IDE. You may refer to this article to create a Dynamic Web Project in STS: How to Create a Dynamic Web Project in Spring Tool Suite?

Step 2: Download the spring JARs file from this link and go to the src > main > webapp > WEB-INF > lib folder and past these JAR files. 

Step 3: Refer to this article Configuration of Apache Tomcat Server and configure the tomcat server with your application. Now we are ready to go.

Step 4: Now go to the src > main > webapp > WEB-INF > web.xml file and here we have to configure our front controller inside a <servlet>…</servlet> tag something like this. 

<servlet>

      <!-- Provide a Servlet Name -->
    <servlet-name>frontcontroller-dispatcher</servlet-name>
    
    <!-- Provide a fully qualified path to the DispatcherServlet class -->
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    

</servlet>
Now let’s tell this servlet, hey servlet you have to handle all the requests coming to our website called student.com (for this example). So the way we are going to tell the above servlet is we can write something like this

<servlet-mapping>

      <!-- Provide a Servlet Name that you want to map -->
    <servlet-name>frontcontroller-dispatcher</servlet-name>
    
    <!-- Provide a url pattern -->
    <url-pattern>/student.com/*</url-pattern>
    
</servlet-mapping>
So this does mean that the servlet “frontcontroller-dispatcher” is going to handle all the requests starting from student.com/anything, that may be student.com/save or student.com/get, anything. But it must start with student.com. So we are done with creating a Dispatcher Servlet. 


Q35	What is a form backing object?

	Form Backing Object/Command Object
This is a POJO that is used to collect all information on a form.  It contains data only.  It is also called a Command Object in some Spring tutorials.  For example, an add a new car form page will have a Car form backing object with attribute data such as Year, Make and Model.  You'll notice that it contains the same attributes as a domain object, thus typically, your domain object can double as a form backing object.

Q36	How is validation done using Spring MVC?
	
	The Spring MVC Validation is used to restrict the input provided by the user. To validate the user's input, the Spring 4 or higher version supports and use Bean Validation API. It can validate both server-side as well as client-side applications.

Bean Validation API
The Bean Validation API is a Java specification which is used to apply constraints on object model via annotations. Here, we can validate a length, number, regular expression, etc. Apart from that, we can also provide custom validations.

As Bean Validation API is just a specification, it requires an implementation. So, for that, it uses Hibernate Validator. The Hibernate Validator is a fully compliant JSR-303/309 implementation that allows to express and validate application constraints.

Validation Annotations
Let's see some frequently used validation annotations.

@NotNull	It determines that the value can't be null.
@Min	It determines that the number must be equal or greater than the specified value.
@Max	It determines that the number must be equal or less than the specified value.
@Size	It determines that the size must be equal to the specified value.
@Pattern	It determines that the sequence follows the specified regular expression.


Q37	What is BindingResult?

	 BindingResult ] is Spring's object that holds the result of the validation and binding and contains errors that may have occurred. The BindingResult must come right after the model object that is validated or else Spring will fail to validate the object and throw an exception.
	 
Q 38	How do you map validation results to your view?

Q39	What are Spring Form Tags ?
	
	The Spring MVC form tags are the configurable and reusable building blocks for a web page. These tags provide JSP, an easy way to develop, read and maintain.

The Spring MVC form tags can be seen as data binding-aware tags that can automatically set data to Java object/bean and also retrieve from it. Here, each tag provides support for the set of attributes of its corresponding HTML tag counterpart, making the tags familiar and easy to use.

Configuration of Spring MVC Form Tag
The form tag library comes under the spring-webmvc.jar. To enable the support for form tag library, it is required to reference some configuration. So, add the following directive at the beginning of the JSP page:

<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %>  
List of Spring MVC Form Tags

Form Tag	Description
form:form	It is a container tag that contains all other form tags.
form:input	This tag is used to generate the text field.
form:radiobutton	This tag is used to generate the radio buttons.
form:checkbox	This tag is used to generate the checkboxes.
form:password	This tag is used to generate the password input field.
form:select	This tag is used to generate the drop-down list.
form:textarea	This tag is used to generate the multi-line text field.
form:hidden	This tag is used to generate the hidden input field.
The form tag
The Spring MVC form tag is a container tag. It is a parent tag that contains all the other tags of the tag library. This tag generates an HTML form tag and exposes a binding path to the inner tags for binding.

Q40	What is a Path Variable?

	Simply put, the @PathVariable annotation can be used to handle template variables in the request URI mapping, and set them as method parameters.
	
Q 41	What is a Model Attribute?
	@ModelAttribute is an annotation that binds a method parameter or method return value to a named model attribute, and then exposes it to a web view.
In this tutorial, we'll demonstrate the usability and functionality of this annotation through a common concept, a form submitted from a company's employee.

Q 42	What is a Session Attribute? 
	The session attribute indicates whether or not the JSP page uses HTTP sessions. A value of true means that the JSP page has access to a builtin session object and a value of false means that the JSP page cannot access the builtin session object.

Following directive allows the JSP page to use any of the builtin object session methods such as session.getCreationTime() or session.getLastAccessTime() −

	Spring JDBC & JPA Problem	Questions
Q1	What is Spring JDBC? How is different from JDBC?
		
	Spring provides a simplification in handling database access with the Spring JDBC Template. The Spring JDBC Template has the following advantages 		compared with standard JDBC.
	
The Spring JDBC template allows to clean-up the resources automatically, e.g. release the database connections.

The Spring JDBC template converts the standard JDBC SQLExceptions into RuntimeExceptions. This allows the programmer to react more flexible to the errors. The Spring JDBC template converts also the vendor specific error messages into better understandable error messages.

The Spring JDBC template offers several ways to query the database. queryForList() returns a list of HashMaps. The name of the column is the key in the hashmap for the values in the table. More convenient is the usage of ResultSetExtractor or RowMapper which allows to translates the SQL result direct into an object (ResultSetExtractor) or a list of objects (RowMapper). Both these methods will be demonstrated in the coding.

Q 2	What is a JdbcTemplate?

	The org.springframework.jdbc.core.JdbcTemplate class is the central class in the JDBC core package. It simplifies the use of JDBC and helps to avoid common errors. It executes core JDBC workflow, leaving the application code to provide SQL and extract results. This class executes SQL queries or updates, initiating iteration over ResultSets and catching JDBC exceptions and translating them to the generic, more informative exception hierarchy defined in the org.springframework.dao package.
	
	
Q3	What is a RowMapper?

	Like ResultSetExtractor, we can use RowMapper interface to fetch the records from the database using query() method of JdbcTemplate class. In the execute of we need to pass the instance of RowMapper now.

Syntax of query method using RowMapper
public T query(String sql,RowMapper<T> rm)  
RowMapper Interface
RowMapper interface allows to map a row of the relations with the instance of user-defined class. It iterates the ResultSet internally and adds it into the collection. So we don't need to write a lot of code to fetch the records as ResultSetExtractor.

Advantage of RowMapper over ResultSetExtractor
RowMapper saves a lot of code becuase it internally adds the data of ResultSet into the collection.

Method of RowMapper interface
It defines only one method mapRow that accepts ResultSet instance and int as the parameter list. Syntax of the method is given below:

public T mapRow(ResultSet rs, int rowNumber)throws SQLException  

Q 4	What is JPA?

The Java Persistence API (JPA) is a specification of Java. It is used to persist data between Java object and relational database. JPA acts as a bridge between object-oriented domain models and relational database systems.

As JPA is just a specification, it doesn't perform any operation by itself. It requires an implementation. So, ORM tools like Hibernate, TopLink and iBatis implements JPA specifications for data persistence.

Q 5	What is Hibernate?
	Hibernate is a Java framework that simplifies the development of Java application to interact with the database. It is an open source, lightweight, ORM (Object Relational Mapping) tool. Hibernate implements the specifications of JPA (Java Persistence API) for data persistence.
	An ORM tool simplifies the data creation, data manipulation and data access. It is a programming technique that maps the object to the data stored in the database.
	
Q 6	How do you define an entity in JPA?
	Entities in JPA are nothing but POJOs representing data that can be persisted to the database. An entity represents a table stored in a database. Every instance of an entity represents a row in the table.
	
Q7	What is an Entity Manager?
	Following are some of the important roles of an entity manager: -

	The entity manager implements the API and encapsulates all of them within a single interface.
	Entity manager is used to read, delete and write an entity.
	An object referenced by an entity is managed by entity manager.
	Steps to persist an entity object.
	1) Creating an entity manager factory object

	The EntityManagerFactory interface present in java.persistence package is used to provide an entity manager.

	EntityManagerFactory emf=Persistence.createEntityManagerFactory("Student_details");  
	Persistence - The Persistence is a bootstrap class which is used to obtain an EntityManagerFactory interface.
	createEntityManagerFactory() method - The role of this method is to create and return an EntityManagerFactory for the named persistence unit. Thus, this 	 method contains the name of persistence unit passed in the Persistence.xml file.

Q 8	What is a Persistence Context?

	An EntityManager instance is associated with a persistence context. A persistence context is a set of entity instances in which for any persistent entity 	 identity there is a unique entity instance. Within the persistence context, the entity instances and their lifecycle are managed. The EntityManager API is used 	to create and remove persistent entity instances, to find entities by their primary key, and to query over entities.

The above statement may seem a bit complex right now, but it will make complete sense as we proceed. The persistence context is the first-level cache where all the entities are fetched from the database or saved to the database. It sits between our application and persistent storage.

Persistence context keeps track of any changes made into a managed entity. If anything changes during a transaction, then the entity is marked as dirty. When the transaction completes, these changes are flushed into persistent storage.

Q9	How do you map relationships in JPA?

	@ManyToOne Relation
@OneToMany Relation
@OneToOne Relation
@ManyToMany Relation
@ManyToOne Relation
Many-To-One relation between entities: Where one entity (column or set of columns) is/are referenced with another entity (column or set of columns) which contain unique values. In relational databases these relations are applicable by using foreign key/primary key between tables.

Let us consider an example of relation between Employee and Department entities. In unidirectional manner, i.e.from Employee to Department, Many-To-One relation is applicable. That means each record of employee contains one department id, which should be a primary key in Department table. Here in the Employee table, Department id is foreign Key.

Q10	What are the different types of relationships in JPA?
	Same as above
Q11	How do you define One to One Mapping in JPA?
	
	In JPA One-To-One mapping, a single instance of one entity is associated with another single instance of another entity.

	Basically, a single-valued association is implemented by JPA One-To-One Mapping. For this type of Mapping association, we can only map the source entity to 	    the utmost one instance of the target entity.

Q12	How do you define One to Many Mapping in JPA?

	The One-To-Many mapping comes into the category of collection-valued association where an entity is associated with a collection of other entities. Hence, in this type of association the instance of one entity can be mapped with any number of instances of another entity.

@OneToMany Example
In this example, we will create a One-To-Many relationship between a Student and Library in such a way that one student can be issued more than one type of book.

This example contains the following steps: -

Create an entity class Student.java under com.javatpoint.mapping package that contains student id (s_id), student name (s_name) with @OneToMany annotation that contains Library class object of List type.
Q13	How do you define Many to Many Mapping in JPA?

	In JPA we use the @ManyToMany annotation to model many-to-many relationships. This type of relationship can be unidirectional or bidirectional:

In a unidirectional relationship only one entity in the relationship points the other.
In a bidirectional relationship both entities point to each other.

Q14	How do you define a datasource in a Spring Context?
		To configure your own DataSource, define a @Bean of that type in your configuration. Spring Boot reuses your DataSource anywhere one is required, including database initialization. If you need to externalize some settings, you can bind your DataSource to the environment (see “Section 25.8.1, “Third-party Configuration””).

The following example shows how to define a data source in a bean:

@Bean
@ConfigurationProperties(prefix="app.datasource")
public DataSource dataSource() {
	return new FancyDataSource();
}

Q15	What is the use of persistence.xml

	The persistence.xml file gives you complete flexibility to configure the EntityManager.

The persistence.xml file is a standard configuration file in JPA. It has to be included in the META-INF directory inside the JAR file that contains the entity beans. The persistence.xml file must define a persistence-unit with a unique name in the current scoped classloader.

Q16	How do you configure Entity Manager Factory and
	Transaction Manager?	
	
	Configuring the Entity Manager Factory Bean
We can configure the entity manager factory bean by following these steps:

Create a new LocalContainerEntityManagerFactoryBean object. We need to create this object because it creates the JPA EntityManagerFactory.
Configure the used datasource.
Configure the Hibernate specific implementation of the JpaVendorAdapter interface. It will initialize our configuration with the default settings that are compatible with Hibernate.
Configure the packages that are scanned for entity classes.
Configure the JPA properties that are used to provide additional configuration to the used JPA provider.
The method that configures the entity manager factory bean looks as follows:

@Configuration
class PersistenceContext {
 
    @Bean
    LocalContainerEntityManagerFactoryBean entityManagerFactory(DataSource dataSource, 
                                                                Environment env) {
        LocalContainerEntityManagerFactoryBean entityManagerFactoryBean = new LocalContainerEntityManagerFactoryBean();
        entityManagerFactoryBean.setDataSource(dataSource);
        entityManagerFactoryBean.setJpaVendorAdapter(new HibernateJpaVendorAdapter());
        entityManagerFactoryBean.setPackagesToScan("net.petrikainulainen.springdata.jpa.todo");
 
        Properties jpaProperties = new Properties();
     
        //Configures the used database dialect. This allows Hibernate to create SQL
        //that is optimized for the used database.
        jpaProperties.put("hibernate.dialect", env.getRequiredProperty("hibernate.dialect"));
 
        //Specifies the action that is invoked to the database when the Hibernate
        //SessionFactory is created or closed.
        jpaProperties.put("hibernate.hbm2ddl.auto", 
                env.getRequiredProperty("hibernate.hbm2ddl.auto")
        );
 
        //Configures the naming strategy that is used when Hibernate creates
        //new database objects and schema elements
        jpaProperties.put("hibernate.ejb.naming_strategy", 
                env.getRequiredProperty("hibernate.ejb.naming_strategy")
        );
 
        //If the value of this property is true, Hibernate writes all SQL
        //statements to the console.
        jpaProperties.put("hibernate.show_sql", 
                env.getRequiredProperty("hibernate.show_sql")
        );
 
        //If the value of this property is true, Hibernate will format the SQL
        //that is written to the console.
        jpaProperties.put("hibernate.format_sql", 
                env.getRequiredProperty("hibernate.format_sql")
        );
 
        entityManagerFactoryBean.setJpaProperties(jpaProperties);
 
        return entityManagerFactoryBean;
    }
     
    //Add the other beans here
}

Let’s move on and configure the transaction manager bean.

Configuring the Transaction Manager Bean
Because we are using JPA, we have to create a transaction manager bean that integrates the JPA provider with the Spring transaction mechanism. We can do this by using the JpaTransactionManager class as the transaction manager of our application.

We can configure the transaction manager bean by following these steps:

Create a new JpaTransactionManager object.
Configure the entity manager factory whose transactions are managed by the created JpaTransactionManager object.
The method that configures the transaction manager bean looks as follows:


@Configuration
class PersistenceContext {
 
    @Bean
    JpaTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {
        JpaTransactionManager transactionManager = new JpaTransactionManager();
        transactionManager.setEntityManagerFactory(entityManagerFactory);
        return transactionManager;
    }
     
    //Add the other beans here
}

Q17	How do you define transaction management for Spring – Hibernate integration?
	
	What Spring-Hibernate transaction management by Annotation does?

The Spring-Hibernate transaction management by Annotation makes sure :

The transaction operations i.e. amount deposit or withdrawn should be atomic i.e. either of these operations should happen entirely or nothing at all.

The transaction operations trying to access the shared data at the same time, should only be executed in isolation. i.e. one transaction at a time.

In case of any exceptional or erroneous situation taking place(while any of the deposit or withdraw transaction operations were being performed), the effect of these operations should be rolled back to maintain the consistency of data and not leave any anomalous data in the database.





How Spring-Hibernate transaction management by Annotation works?

To perform transaction management within the database using Spring Framework with Hibernate and Annotations, we need an access to the source code to edit it and add @Transactional Annotation to class and methods involved in performing the transaction operations.




Note :

Before we proceed with the example of database transaction management, we would first need to configure Spring Framework to work with Hibernate. To perform this, we will use a very important template class provided by Spring Framework, named - HibernateTemplate, which provides different methods for querying and retrieving data from the database.




Creating the Java class - Customer_Account

We are going to create a java class named Customer_Account within the decodejava package and this class contains -
An int property named id.
A String property named name.
A String property named address.
A String property named age.
This class and its properties will be annotated with @Entity, @Table, @Id, @Column, @GeneratedValue annotations, which allow us to create a database table with a primary key id and columns without using a mapping resource xml file. For those who are unaware of these Hibernate Annotations, please read our article Hibernate with Annotations.

Besides this, we are also going to define a couple of getter and setter methods within this class to set the above mentioned properties of Customer class.

Problem 18	What is Spring Data?

		Spring Data’s mission is to provide a familiar and consistent, Spring-based programming model for data access while still retaining the special traits of the underlying data store.

It makes it easy to use data access technologies, relational and non-relational databases, map-reduce frameworks, and cloud-based data services. This is an umbrella project which contains many subprojects that are specific to a given database. The projects are developed by working together with many of the companies and developers that are behind these exciting technologies.

Features
Powerful repository and custom object-mapping abstractions

Dynamic query derivation from repository method names

Implementation domain base classes providing basic properties

Support for transparent auditing (created, last changed)

Possibility to integrate custom repository code

Easy Spring integration via JavaConfig and custom XML namespaces

Advanced integration with Spring MVC controllers

Experimental support for cross-store persistence

Main modules
Spring Data Commons - Core Spring concepts underpinning every Spring Data module.

Spring Data JDBC - Spring Data repository support for JDBC.

Spring Data JDBC Ext - Support for database specific extensions to standard JDBC including support for Oracle RAC fast connection failover, AQ JMS support and support for using advanced data types.

Spring Data JPA - Spring Data repository support for JPA.

Spring Data KeyValue - Map based repositories and SPIs to easily build a Spring Data module for key-value stores.

Spring Data LDAP - Spring Data repository support for Spring LDAP.

Spring Data MongoDB - Spring based, object-document support and repositories for MongoDB.

Spring Data Redis - Easy configuration and access to Redis from Spring applications.

Spring Data REST - Exports Spring Data repositories as hypermedia-driven RESTful resources.

Spring Data for Apache Cassandra - Easy configuration and access to Apache Cassandra or large scale, highly available, data oriented Spring applications.

Spring Data for Apache Geode - Easy configuration and access to Apache Geode for highly consistent, low latency, data oriented Spring applications.

Spring Data for VMware Tanzu GemFire - Easy configuration and access to Pivotal GemFire for your highly consistent, low latency/high through-put, data-oriented Spring applications.


Q19	What is the need for Spring Data?
		Same as previous.

Q20	What is Spring Data JPA?
	Spring Data JPA API provides JpaTemplate class to integrate spring application with JPA.

JPA (Java Persistent API) is the sun specification for persisting objects in the enterprise application. It is currently used as the replacement for complex entity beans.

The implementation of JPA specification are provided by many vendors such as:

Hibernate
Toplink
iBatis
OpenJPA etc.
Advantage of Spring JpaTemplate
You don't need to write the before and after code for persisting, updating, deleting or searching object such as creating Persistence instance, creating EntityManagerFactory instance, creating EntityTransaction instance, creating EntityManager instance, commiting EntityTransaction instance and closing EntityManager.

Q21	What is a CrudRepository?
	CrudRepository and JPA repository both are the interface of the spring data repository library. Spring data repository reduces the boilerplate code by providing some predefined finders to access the data layer for various persistence layers.

JPA repository extends CrudRepository and PagingAndSorting repository. It inherits some finders from crud repository such as findOne, gets and removes an entity. It also provides some extra methods related to JPA such as delete records in batch, flushing data directly to a database base and methods related to pagination and sorting.

We need to extend this repository in our application and then we can access all methods which are available in these repositories. We can also add new methods using named or native queries based on business requirements.

Example of JpaRepository
@Repository
public interface BookDAO extends JpaRepository {
   Book findByAuthor(@Param("id") Integer id);
}
Example of CrudRepository
@Repository
public interface BookDAO extends CrudRepository {
   Book Event findById(@Param("id") Integer id);
}

q22	What is a PagingAndSortingRepository? 
	
	1407


JpaRepository extends PagingAndSortingRepository which in turn extends CrudRepository.

Their main functions are:

CrudRepository mainly provides CRUD functions.
PagingAndSortingRepository provides methods to do pagination and sorting records.
JpaRepository provides some JPA-related methods such as flushing the persistence context and deleting records in a batch.
Because of the inheritance mentioned above, JpaRepository will have all the functions of CrudRepository and PagingAndSortingRepository. So if you don't need the repository to have the functions provided by JpaRepository and PagingAndSortingRepository , use CrudRepository.


Notes

Exceptional Handling & Versioning
Problem	Questions
Problem 1	How do you implement Exception Handling for
RESTFul Web Services?	
1. Create handler with @ControllerAdvice and @ExceptionHandler
@ControllerAdvice annotation is specialization of @Component annotation and it’s methods (annotated with @ExceptionHandler) are shared across multiple @Controller classes, globally.
Classes with @ControllerAdvice are auto-detected via classpath scanning.
Use selectors annotations(), basePackageClasses(), and basePackages() to define a more narrow subset of targeted controllers.
We can apply OR operator in selector i.e. a given method would be executed if any one of given exception is encountered.
Please note that ResponseEntityExceptionHandler is a convenient base class for @ControllerAdvice classes that wish to provide centralized exception handling across all @RequestMapping methods through @ExceptionHandler methods.

import java.util.ArrayList;
import java.util.List;
 
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;
 
@ControllerAdvice
public class CustomExceptionHandler extends ResponseEntityExceptionHandler 
{
  private String INCORRECT_REQUEST = "INCORRECT_REQUEST";
  private String BAD_REQUEST = "BAD_REQUEST";
   
  @ExceptionHandler(RecordNotFoundException.class)
  public final ResponseEntity<ErrorResponse> handleUserNotFoundException
            (RecordNotFoundException ex, WebRequest request) 
  {
    List<String> details = new ArrayList<>();
    details.add(ex.getLocalizedMessage());
    ErrorResponse error = new ErrorResponse(INCORRECT_REQUEST, details);
    return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
  }
   
  @ExceptionHandler(MissingHeaderInfoException.class)
  public final ResponseEntity<ErrorResponse> handleInvalidTraceIdException
            (MissingHeaderInfoException ex, WebRequest request) {
    List<String> details = new ArrayList<>();
    details.add(ex.getLocalizedMessage());
    ErrorResponse error = new ErrorResponse(BAD_REQUEST, details);
    return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
  }
}


2. Create exception model classes
We need to identify the business exception usecases and denote them with exception classes. These classes will extend the RuntimeException class. Also feel free to create more representations of error responses, as per requirements.

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;
 
@ResponseStatus(HttpStatus.BAD_REQUEST)
public class MissingHeaderInfoException extends RuntimeException
{
  private static final long serialVersionUID = 1L;
 
  public MissingHeaderInfoException(String message) {
        super(message);
    }
}
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;
 
@ResponseStatus(HttpStatus.NOT_FOUND)
public class RecordNotFoundException extends RuntimeException
{
  private static final long serialVersionUID = 1L;
 
  public RecordNotFoundException(String message) {
        super(message);
    }
}
import java.util.List;
 
public class ErrorResponse
{
    public ErrorResponse(String message, List<String> details) {
        super();
        this.message = message;
        this.details = details;
    }
  
    private String message;
    private List<String> details;
 
  //getters and setters
}
3. Configure view resolver
If not done already, we need to configure the view resolver to convert the exception messages to XML or JSON form.

In Spring boot, this configuration is done automatically. Without spring boot, we need to do it like below.

Important: Make sure we you have mvc:annotation-driven configuration enabled or used @EnableWebMvc annotation.

<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
  xmlns:mvc="http://www.springframework.org/schema/mvc"
  xmlns:jpa="http://www.springframework.org/schema/data/jpa"
  xmlns:tx="http://www.springframework.org/schema/tx"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
  http://www.springframework.org/schema/beans/spring-beans.xsd
  http://www.springframework.org/schema/context/
  http://www.springframework.org/schema/context/spring-context.xsd
  http://www.springframework.org/schema/data/jpa/ 
    http://www.springframework.org/schema/data/jpa/spring-jpa-1.0.xsd
    http://www.springframework.org/schema/tx/ 
    http://www.springframework.org/schema/tx/spring-tx-4.0.xsd
  http://www.springframework.org/schema/mvc/
  http://www.springframework.org/schema/mvc/spring-mvc.xsd">
 
  <mvc:annotation-driven />
 
  <context:component-scan base-package="com.howtodoinjava.demo" />
   
  <mvc:view-resolvers>
        <mvc:content-negotiation>
            <mvc:default-views>
                <bean class="org.springframework.web.servlet.view.json.MappingJackson2JsonView"/>
            </mvc:default-views>
        </mvc:content-negotiation>
    </mvc:view-resolvers>
   
  <!-- JPA Config -->
</beans>
4. REST controller changes
From rest controller handler method, we need to throw the exception which we want to convert and send as response to API consumer. In this case, we are sending RecordNotFoundException in case an employee is searched by id and it does not exist in the database.

@GetMapping("/employees/{id}")
Employee getEmployeeById(@PathVariable Long id) 
{
  return repository.findById(id)
      .orElseThrow(() -> new RecordNotFoundException("Employee id '" + id + "' does no exist"));
}
5. Spring REST Exception Handling Demo
Try to get an employee by id where id does not exist in database.

HTTP GET : http://localhost:8080/SpringRestExample/api/rest/employee-management/employees/101
{
  "message": "INCORRECT_REQUEST",
  "details": [
      "Employee id '101' does no exist"
  ],
}
Drop me your questions related exception handling in spring rest apis.

Happy Learning !!

Q2	What are the different error status that you would return in RESTful Web Services?
		
		HTTP defines these standard status codes that can be used to convey the results of a client’s request. The status codes are divided into five categories.

1xx: Informational – Communicates transfer protocol-level information.
2xx: Success – Indicates that the client’s request was accepted successfully.
3xx: Redirection – Indicates that the client must take some additional action in order to complete their request.
4xx: Client Error – This category of error status codes points the finger at clients.
5xx: Server Error – The server takes responsibility for these error status codes.
1xx Status Codes [Informational]
Status Code
Description
100 Continue
An interim response. Indicates to the client that the initial part of the request has been received and has not yet been rejected by the server. The client SHOULD continue by sending the remainder of the request or, if the request has already been completed, ignore this response. The server MUST send a final response after the request has been completed.
101 Switching Protocol
Sent in response to an Upgrade request header from the client, and indicates the protocol the server is switching to.
102 Processing (WebDAV)
Indicates that the server has received and is processing the request, but no response is available yet.
103 Early Hints
Primarily intended to be used with the Link header. It suggests the user agent start preloading the resources while the server prepares a final response.
2xx Status Codes [Success]
Status Code
Description
200 OK
Indicates that the request has succeeded.
201 Created
Indicates that the request has succeeded and a new resource has been created as a result.
202 Accepted
Indicates that the request has been received but not completed yet. It is typically used in log running requests and batch processing.
203 Non-Authoritative Information
Indicates that the returned metainformation in the entity-header is not the definitive set as available from the origin server, but is gathered from a local or a third-party copy. The set presented MAY be a subset or superset of the original version.
204 No Content
The server has fulfilled the request but does not need to return a response body. The server may return the updated meta information.
205 Reset Content
Indicates the client to reset the document which sent this request.
206 Partial Content
It is used when the Range header is sent from the client to request only part of a resource.
207 Multi-Status (WebDAV)
An indicator to a client that multiple operations happened, and that the status for each operation can be found in the body of the response.
208 Already Reported (WebDAV)
Allows a client to tell the server that the same resource (with the same binding) was mentioned earlier. It never appears as a true HTTP response code in the status line, and only appears in bodies.
226 IM Used
The server has fulfilled a GET request for the resource, and the response is a representation of the result of one or more instance-manipulations applied to the current instance.
3xx Status Codes [Redirection]
Status Code
Description
300 Multiple Choices
The request has more than one possible response. The user-agent or user should choose one of them.
301 Moved Permanently
The URL of the requested resource has been changed permanently. The new URL is given by the Location header field in the response. This response is cacheable unless indicated otherwise.
302 Found
The URL of the requested resource has been changed temporarily. The new URL is given by the Location field in the response. This response is only cacheable if indicated by a Cache-Control or Expires header field.
303 See Other
The response can be found under a different URI and SHOULD be retrieved using a GET method on that resource.
304 Not Modified
Indicates the client that the response has not been modified, so the client can continue to use the same cached version of the response.
305 Use Proxy (Deprecated)
Indicates that a requested response must be accessed by a proxy.
306 (Unused)
It is a reserved status code and is not used anymore.
307 Temporary Redirect
Indicates the client to get the requested resource at another URI with same method that was used in the prior request. It is similar to 302 Found with one exception that the same HTTP method will be used that was used in the prior request.
308 Permanent Redirect (experimental)
Indicates that the resource is now permanently located at another URI, specified by the Location header. It is similar to 301 Moved Permanently with one exception that the same HTTP method will be used that was used in the prior request.
4xx Status Codes (Client Error)
Status Code
Description
400 Bad Request
The request could not be understood by the server due to incorrect syntax. The client SHOULD NOT repeat the request without modifications.
401 Unauthorized
Indicates that the request requires user authentication information. The client MAY repeat the request with a suitable Authorization header field
402 Payment Required (Experimental)
Reserved for future use. It is aimed for using in the digital payment systems.
403 Forbidden
Unauthorized request. The client does not have access rights to the content. Unlike 401, the client’s identity is known to the server.
404 Not Found
The server can not find the requested resource.
405 Method Not Allowed
The request HTTP method is known by the server but has been disabled and cannot be used for that resource.
406 Not Acceptable
The server doesn’t find any content that conforms to the criteria given by the user agent in the Accept header sent in the request.
407 Proxy Authentication Required
Indicates that the client must first authenticate itself with the proxy.
408 Request Timeout
Indicates that the server did not receive a complete request from the client within the server’s allotted timeout period.
409 Conflict
The request could not be completed due to a conflict with the current state of the resource.
410 Gone
The requested resource is no longer available at the server.
411 Length Required
The server refuses to accept the request without a defined Content- Length. The client MAY repeat the request if it adds a valid Content-Length header field.
412 Precondition Failed
The client has indicated preconditions in its headers which the server does not meet.
413 Request Entity Too Large
Request entity is larger than limits defined by server.
414 Request-URI Too Long
The URI requested by the client is longer than the server can interpret.
415 Unsupported Media Type
The media-type in Content-type of the request is not supported by the server.
416 Requested Range Not Satisfiable
The range specified by the Range header field in the request can’t be fulfilled.
417 Expectation Failed
The expectation indicated by the Expect request header field can’t be met by the server.
418 I’m a teapot (RFC 2324)
It was defined as April’s lool joke and is not expected to be implemented by actual HTTP servers. (RFC 2324)
420 Enhance Your Calm (Twitter)
Returned by the Twitter Search and Trends API when the client is being rate limited.
422 Unprocessable Entity (WebDAV)
The server understands the content type and syntax of the request entity, but still server is unable to process the request for some reason.
423 Locked (WebDAV)
The resource that is being accessed is locked.
424 Failed Dependency (WebDAV)
The request failed due to failure of a previous request.
425 Too Early (WebDAV)
Indicates that the server is unwilling to risk processing a request that might be replayed.
426 Upgrade Required
The server refuses to perform the request. The server will process the request after the client upgrades to a different protocol.
428 Precondition Required
The origin server requires the request to be conditional.
429 Too Many Requests
The user has sent too many requests in a given amount of time (“rate limiting”).
431 Request Header Fields Too Large
The server is unwilling to process the request because its header fields are too large.
444 No Response (Nginx)
The Nginx server returns no information to the client and closes the connection.
449 Retry With (Microsoft)
The request should be retried after performing the appropriate action.
450 Blocked by Windows Parental Controls (Microsoft)
Windows Parental Controls are turned on and are blocking access to the given webpage.
451 Unavailable For Legal Reasons
The user-agent requested a resource that cannot legally be provided.
499 Client Closed Request (Nginx)
The connection is closed by the client while HTTP server is processing its request, making the server unable to send the HTTP header back.
5xx Status Codes (Server Error)
Status Code
Description
500 Internal Server Error
The server encountered an unexpected condition that prevented it from fulfilling the request.
501 Not Implemented
The HTTP method is not supported by the server and cannot be handled.
502 Bad Gateway
The server got an invalid response while working as a gateway to get the response needed to handle the request.
503 Service Unavailable
The server is not ready to handle the request.
504 Gateway Timeout
The server is acting as a gateway and cannot get a response in time for a request.
505 HTTP Version Not Supported (Experimental)
The HTTP version used in the request is not supported by the server.
506 Variant Also Negotiates (Experimental)
Indicates that the server has an internal configuration error: the chosen variant resource is configured to engage in transparent content negotiation itself, and is therefore not a proper endpoint in the negotiation process.
507 Insufficient Storage (WebDAV)
The method could not be performed on the resource because the server is unable to store the representation needed to successfully complete the request.
508 Loop Detected (WebDAV)
The server detected an infinite loop while processing the request.
510 Not Extended
Further extensions to the request are required for the server to fulfill it.
511 Network Authentication Required

Q3 How would you implement them using Spring Boot?
Problem 4	How do you handle Validation Errors with RESTful
Web Services?	
Problem 5	Why do we need Versioning for RESTful Web
Services?	
Problem 6	What are the versioning options that are available?
Problem 7	How do you implement Versioning for RESTful Web
Services?
