1) What is Loose Coupling?

Loose coupling : In simple words, loose coupling means they are mostly independent. If the only knowledge that class A has about class B, is what class B has exposed through its interface, then class A and class B are said to be loosely coupled. In order to over come from the problems of tight coupling between objects, spring framework uses dependency injection mechanism with the help of POJO/POJI model and through dependency injection its possible to achieve loose coupling.
Example : If you change your shirt, then you are not forced to change your body – when you can do that, then you have loose coupling. When you can’t do that, then you have tight coupling. The examples of Loose coupling are Interface, JMS.
// Java program to illustrate 
// loose coupling concept
public interface Topic
{
    void understand();
}
class Topic1 implements Topic {
	public void understand()
    	{
        	System.out.println("Got it");
    	}
} class Topic2 implements Topic {
	public void understand()
    	{
        	System.out.println("understand");
    	}
}public class Subject {
	public static void main(String[] args)
    	{
        	Topic t = new Topic1();
        	t.understand();
    	}
}

2) What is Dependency?

A typical Java application will have three layers in its architecture: web, business and data.

The web layer
The business layer
The data layer
In the above scenario:

Web Layer depends on Business Layer. The business layer is a dependency for the web layer.
Business layer depends on Data Layer. The data layer is a dependency for the business layer.

3) What is IOC (Inversion of Control)?
In general, when a class depends on another class then the dependent class creates the object of its
dependency class directly, and then uses(call) its methods, it is called the dependency object created in the main control.
But if some external entity is taking care of creating the dependency object then we say that control is inverted to some external entity, this is called Inversion of Control (IOC).

4) What is Dependency Injection?
Dependency Injection is a fundamental aspect of the Spring framework, through which the Spring container “injects” objects into other objects or “dependencies”.

Simply put, this allows for loose coupling of components and moves the responsibility of managing components onto the container.

5) Can you give few examples of Dependency Injection ?
Example Car Class might need a reference to an Engine class . These required classe are called dependencies and in the example the car class is dependent on having an instance of the  engine class to run.

6) What is Auto Wiring?
Autowiring feature of spring framework enables you to inject the object dependency implicitly. It internally uses setter or constructor injection.
Autowiring can't be used to inject primitive and string values. It works with reference only.
1)	no:-		It is the default autowiring mode. It means no autowiring bydefault.
2)	byName:-	The byName mode injects the object dependency according to name of the bean. In such case, property name and bean name must be same. It 			internally calls setter method.
3)	byType:-	The byType mode injects the object dependency according to type. So property name and bean name can be different. It internally calls setter 			     method.
4)	constructor:-	The constructor mode injects the dependency by calling the constructor of the class. It calls the constructor having large number of 				parameters.
5)	autodetect:-	It is deprecated since Spring 3.

7) What are the important roles of an IOC Container?
	The IoC container is responsible to instantiate, configure and assemble the objects. The IoC container gets informations from the XML file and works 		accordingly. The main tasks performed by IoC container are:
	1) to instantiate the application class
	2) to configure the object
	3) to assemble the dependencies between the objects
	
	There are two types of IoC containers. They are:

	BeanFactory
	ApplicationContext

8) 	What are Bean Factory and Application Context?
	Spring Framework provides two of the most fundamental and important packages, they are the org.springframework.beans and org.springframework.context packages. 		Code in these packages provides the basis for Spring’s Inversion of Control/Dependency Injection features. Spring containers are responsible for creating bean 		objects and injecting them into the classes. The two containers are namely,

	BeanFactory(I) – Available in org.springframework.beans.factory package.
	ApplicationContext(I) – Available in rg.springframework.context package.
	
	The BeanFactory Interface
	This is the root interface for accessing a Spring bean container. It is the actual container that instantiates, configures, and manages a number of beans. 	   These beans collaborate with one another and thus have dependencies between themselves. These dependencies are reflected in the configuration data used by the 	  BeanFactory. This interface is implemented by the objects that hold a number of bean definitions, each uniquely identified by a String name. The most common 	         implementation class used for this BeanFactory is XmlBeanFactory available in org.springframework.beans.factory.xml package. 


	Note: BeanFactory is deprecated from Spring 3.0.

	Example code:
	ClassPathResource resource = new ClassPathResource("beans.xml");
	XmlBeanFactory factory = new XmlBeanFactory(resource);
 
 

	The ApplicationContext Interface
 

	This interface is designed on top of the BeanFactory interface. The ApplicationContext interface is the advanced container that enhances BeanFactory 		functionality in a more framework-oriented style. While the BeanFactory provides basic functionality for managing and manipulating beans, often in a 		programmatic way, the ApplicationContext provides extra functionality like MessageSource, Access to resources, Event propagation to beans, Loading of multiple 		(hierarchical) contexts etc. There are so many implementation classes that can be used such as ClassPathXmlApplicationContext,FileSystemXmlApplicationContext, 		AnnotationConfigWebApplicationContext etc.


	Example code:
	ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
	
	
9) 	Can you compare Bean Factory with Application Context?

	BeanFactory loads beans on-demand, while ApplicationContext loads all beans at startup. Thus, BeanFactory is lightweight as compared to ApplicationContext. 	    Let's understand it with an example.
	
	public class Student {
    public static boolean isBeanInstantiated = false;

    public void postConstruct() {
        setBeanInstantiated(true);
    }
}

10) How do you create an application context with Spring?

Step 1: Creating a Spring Project using Spring Initializer as pictorially depicted below.



Step 2: Create Student class under com.gfg.demo.domain and AppConfig class under com.gfg.demo.config packages. The AppConfig is the configuration class that contains all the Java beans configured using Java Based Configuration. The Student class is the POJO class.

Class 1: AppConfig class
@Configuration

// Class
public class AppConfig {

  @Bean

  // Method
  public Student student() {

    return new Student(1, "Geek");
  }
}
Class 2: Student class
// Class
public class Student {

  // member variables
  private int id;
  private String name;

  // Constructor 1
  public Student() {}

  // Constructor 2
  public Student(int id, String name) {
    this.id = id;
    this.name = name;
  }

  // Method of this class
  // @Override
  public String toString() {

    return "Student{" + "id=" + id + ", name='" + name + '\'' + '}';
  }
}
Step 3: Now the Main Application class at the root contains the creation of a container.

// Class
// @SpringBootApplication
public class DemoApplication {

  // Main driver method
  public static void main(String[] args) {

    // SpringApplication.run(DemoApplication.class, args);

    // Creating its object
    ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
    Student student = context.getBean(Student.class);

    // Print and display
    System.out.println(student);
  }
}
Step 4: The SpringApplication.run() method is provided by default in the main class when the SpringBoot project is created. It creates the container, creates beans, manages dependency injection and life cycle of those beans. This is done using @SpringBootApplication annotation.


Q11 How does Spring know where to search for Components or Beans?


If you understand Component Scan, you understand Spring.

Spring is a dependency injection framework. It is all about beans and wiring in dependencies.

The first step of defining Spring Beans is by adding the right annotation — @Component or @Service or @Repository.

However, Spring does not know about the bean unless it knows where to search for it.

This part of “telling Spring where to search” is called a Component Scan.

You define the packages that have to be scanned.

Once you define a Component Scan for a package, Spring would search the package and all its sub packages for components/beans.

Defining a Component Scan

If you are using Spring Boot, check the configuration in Approach 1.
If you are doing a JSP/Servlet or a Spring MVC application without using Spring Boot, use Approach 2.
Approach 1: Component Scan in a Spring Boot Project

If your other package hierarchies are below your main app with the @SpringBootApplication annotation, you’re covered by the implicit Component Scan. If there are beans/components in other packages that are not sub-packages of the main package, you should manually add them as @ComponentScan

Consider below class

package com.in28minutes.springboot.basics.springbootin10steps;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ConfigurableApplicationContext;
@SpringBootApplication
public class SpringbootIn10StepsApplication {
    public static void main(String[] args) {
        ApplicationContext applicationContext =
            SpringApplication.run(SpringbootIn10StepsApplication.class, args);
        for (String name: applicationContext.getBeanDefinitionNames()) {
            System.out.println(name);
        }
    }
}
@SpringBootApplication is defined in the SpringbootIn10StepsApplication class which is in the package com.in28minutes.springboot.basics.springbootin10steps

@SpringBootApplication defines an automatic Component Scan on the package com.in28minutes.springboot.basics.springbootin10steps.

You are fine if all your components are defined in the above package or a sub-package of it.

However, let’s say one of the components is defined in package com.in28minutes.springboot.somethingelse

In this case, you would need to add the new package into Component Scan.

You have two options:

Option 1:

@ComponentScan(“com.in28minutes.springboot”)
@SpringBootApplication
public class SpringbootIn10StepsApplication {...}
Option 2:: Define as array

@ComponentScan({"com.in28minutes.springboot.basics.springbootin10steps","com.in28minutes.springboot.somethingelse"})
@SpringBootApplication
public class SpringbootIn10StepsApplication {...}
Approach 2: Non-Spring Boot Project

Option 1:

@ComponentScan(“com.in28minutes)
@Configuration
public class SpringConfiguration {...}
Option 2:

@ComponentScan({"com.in28minutes.package1","com.in28minutes.package2"})
@Configuration
public class SpringConfiguration {...}
XML application context:

<context:component-scan base-package="com.in28minutes" />
Specific multiple packages:

<context:component-scan base-package="com.in28minutes.package1, com.in28minutes.package2" />


Q12 What is a component scan?
When developing Spring Boot applications, you need to tell the Spring Framework where to look for Spring components. Using component scan is one method of asking Spring to detect Spring managed components. Spring needs the information to locate and register all the Spring components with the application context when the application starts.

Spring can auto scan, detect, and instantiate components from pre-defined project packages. It can auto scan all classes annotated with the stereotype annotations @Component, @Controller, @Service, and @Repository


Q13 How do you define a component scan in XML and
Java Configurations?

To autodetect these classes and register the corresponding beans, you need to include the following element in XML, where the base-package element is a common parent package for the two classes. (Alternatively, you can specify a comma-separated list that includes the parent package of each class.)

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context-3.0.xsd">
               
     <context:component-scan base-package="org.example"/>
     
</beans>


With Spring, we use the @ComponentScan annotation along with the @Configuration annotation to specify the packages that we want to be scanned. @ComponentScan without arguments tells Spring to scan the current package and all of its sub-packages.

Let's say we have the following @Configuration in com.baeldung.componentscan.springapp package:


freestar
@Configuration
@ComponentScan
public class SpringComponentScanApp {
    private static ApplicationContext applicationContext;

    @Bean
    public ExampleBean exampleBean() {
        return new ExampleBean();
    }

    public static void main(String[] args) {
        applicationContext = 
          new AnnotationConfigApplicationContext(SpringComponentScanApp.class);

        for (String beanName : applicationContext.getBeanDefinitionNames()) {
            System.out.println(beanName);
        }
    }
}


Q14 How is it done with Spring Boot?

Already answered above.

Q15 What does @Component signify?

Spring Component
In layman terms, a Component is responsible for some operations. Spring framework provides three other specific annotations to be used when marking a class as Component.

Service: Denotes that the class provides some services. Our utility classes can be marked as Service classes.
Repository: This annotation indicates that the class deals with CRUD operations, usually it’s used with DAO implementations that deal with database tables.
Controller: Mostly used with web applications or REST web services to specify that the class is a front controller and responsible to handle user request and return appropriate response.
Note that all these four annotations are in package org.springframework.stereotype and part of spring-context jar. Most of the time our component classes will fall under one of its three specialized annotations, so you may not use @Component annotation a lot.

Spring Component Example
Let’s create a very simple Spring maven application to showcase the use of Spring Component annotation and how Spring autodetects it with annotation-based configuration and classpath scanning. Create a maven project and add following spring core dependency.

<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-context</artifactId>
	<version>5.0.6.RELEASE</version>
</dependency>
That’s all we need to get the spring framework core features. Let’s create a simple component class and mark it with @Component annotation.

package com.journaldev.spring;

import org.springframework.stereotype.Component;

@Component
public class MathComponent {

	public int add(int x, int y) {
		return x + y;
	}
}
Now we can create an annotation based spring context and get the MathComponent bean from it.

package com.journaldev.spring;

import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class SpringMainClass {

	public static void main(String[] args) {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		context.scan("com.journaldev.spring");
		context.refresh();

		MathComponent ms = context.getBean(MathComponent.class);

		int result = ms.add(1, 2);
		System.out.println("Addition of 1 and 2 = " + result);

		context.close();
	}

}


Q16 What does @Autowired signify?

The @Autowired annotation provides more fine-grained control over where and how autowiring should be accomplished. The @Autowired annotation can be used to autowire bean on the setter method just like @Required annotation, constructor, a property or methods with arbitrary names and/or multiple arguments.


